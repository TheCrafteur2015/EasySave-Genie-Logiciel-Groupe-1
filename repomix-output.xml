This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.editorconfig
.gitignore
build.bat
build.sh
EasyConsole/EasyConsole.csproj
EasyConsole/Program.cs
EasyConsole/View/Command/CommandContext.cs
EasyConsole/View/Command/ICommand.cs
EasyConsole/View/Commands/ChangeLanguageCommand.cs
EasyConsole/View/Commands/CreateBackupJobCommand.cs
EasyConsole/View/Commands/DeleteBackupJobCommand.cs
EasyConsole/View/Commands/ExecuteAllBackupJobsCommand.cs
EasyConsole/View/Commands/ExecuteBackupJobCommand.cs
EasyConsole/View/Commands/ExitCommand.cs
EasyConsole/View/Commands/ListBackupJobsCommand.cs
EasyConsole/View/ConsoleView.cs
EasyGUI/App.axaml
EasyGUI/App.axaml.cs
EasyGUI/app.manifest
EasyGUI/Assets/avalonia-logo.ico
EasyGUI/EasyGUI.csproj
EasyGUI/Program.cs
EasyGUI/ViewLocator.cs
EasyGUI/ViewModels/MainWindowViewModel.cs
EasyGUI/Views/MainWindow.axaml
EasyGUI/Views/MainWindow.axaml.cs
EasyLog/Data/LogEntry.cs
EasyLog/EasyLog.csproj
EasyLog/Logging/AbstractLogger.cs
EasyLog/Logging/ILogger.cs
EasyLog/Logging/JsonLogger.cs
EasyLog/Logging/Level.cs
EasyLog/Logging/LoggerFactory.cs
EasyLog/Logging/SimpleLogger.cs
EasyLog/Logging/XmlLogger.cs
EasyLog/Program.cs
EasySave.sln
EasySave/Backup/BackupJob.cs
EasySave/Backup/BackupManager.cs
EasySave/Backup/BackupStrategyFactory.cs
EasySave/Backup/BackupType.cs
EasySave/Backup/CompleteBackupStrategy.cs
EasySave/Backup/DifferentialBackupStrategy.cs
EasySave/Backup/IBackupStrategy.cs
EasySave/Backup/ProgressState.cs
EasySave/Backup/Signal.cs
EasySave/Backup/State.cs
EasySave/ClassDiagram.cd
EasySave/default.json
EasySave/EasySave.csproj
EasySave/Extensions/BackupTypeExt.cs
EasySave/Extensions/ConsoleExt.cs
EasySave/Extensions/StateExt.cs
EasySave/global.json
EasySave/i18n/en_us.json
EasySave/i18n/fr_fr.json
EasySave/Program.cs
EasySave/Properties/launchSettings.json
EasySave/Properties/PublishProfiles/FolderProfile.pubxml
EasySave/Utils/ConfigurationManager.cs
EasySave/Utils/PathUtils.cs
EasySave/Utils/ResourceManager.cs
EasySave/Utils/StateWriter.cs
EasySave/View/Localization/I18n.cs
EasyTest/BackupManagerTests.cs
EasyTest/BackupStrategyTests.cs
EasyTest/EasyTest.csproj
EasyTest/LogTests.cs
EasyTest/MSTestSettings.cs
EasyTest/Test1.cs
EasyTest/TestConfigManager.cs
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".editorconfig">
[*.cs]

# IDE0060: Supprimer le paramètre inutilisé
dotnet_diagnostic.IDE0060.severity = none
</file>

<file path=".gitignore">
## Ignore Visual Studio temporary files, build results, and
## files generated by popular Visual Studio add-ons.

# User-specific files
*.rsuser
*.suo
*.user
*.userosscache
*.sln.docstates

# Build results
[Dd]ebug/
[Dd]ebugPublic/
[Rr]elease/
[Rr]eleases/
x64/
x86/
[Ww][Ii][Nn]32/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
bld/
[Bb]in/
[Oo]bj/
[Ll]og/
[Ll]ogs/

# Visual Studio cache/options directory
.vs/

# Visual Studio Code
.vscode/

# ReSharper
_ReSharper*/
*.[Rr]e[Ss]harper
*.DotSettings.user

# NuGet Packages
*.nupkg
**/packages/*
!**/packages/build/

# MSTest test results
[Tt]est[Rr]esult*/
[Bb]uild[Ll]og.*

# .NET Core
project.lock.json
project.fragment.lock.json
artifacts/

# Files built by Visual Studio
*_i.c
*_p.c
*_h.h
*.ilk
*.meta
*.obj
*.iobj
*.pch
*.pdb
*.ipdb
*.pgc
*.pgd
*.rsp
*.sbr
*.tlb
*.tli
*.tlh
*.tmp
*.tmp_proj
*_wpftmp.csproj
*.log
*.vspscc
*.vssscc
.builds
*.pidb
*.svclog
*.scc

# Backup & report files from converting an old project file
_UpgradeReport_Files/
UpgradeLog*.XML
UpgradeLog*.htm
ServiceFabricBackup/
*.rptproj.bak

# Mac
.DS_Store

publish/
</file>

<file path="build.bat">
@echo off
REM EasySave V1.0 Build Script for Windows
REM This script builds the EasySave project for multiple platforms

echo ================================
echo EasySave V1.0 Build Script
echo ================================
echo.

REM Check if dotnet is installed
where dotnet >nul 2>nul
if %ERRORLEVEL% NEQ 0 (
    echo Error: .NET SDK is not installed
    echo Please install .NET 8.0 SDK from https://dotnet.microsoft.com/download
    pause
    exit /b 1
)

echo Checking .NET version...
dotnet --version
echo.

REM Clean previous builds
echo Cleaning previous builds...
dotnet clean EasySave.sln
echo.

REM Restore dependencies
echo Restoring NuGet packages...
dotnet restore EasySave.sln
echo.

REM Build Debug configuration
echo Building Debug configuration...
dotnet build EasySave.sln -c Debug
if %ERRORLEVEL% EQU 0 (
    echo [32m✓ Debug build successful[0m
) else (
    echo [31m✗ Debug build failed[0m
    pause
    exit /b 1
)
echo.

REM Build Release configuration
echo Building Release configuration...
dotnet build EasySave.sln -c Release
if %ERRORLEVEL% EQU 0 (
    echo [32m✓ Release build successful[0m
) else (
    echo [31m✗ Release build failed[0m
    pause
    exit /b 1
)
echo.

REM Publish for Windows
echo Publishing for Windows (x64)...
dotnet publish EasySave/EasySave.csproj -c Release -r win-x64 --self-contained false -o ./publish/win-x64
if %ERRORLEVEL% EQU 0 (
    echo [32m✓ Windows x64 publish successful[0m
) else (
    echo [31m✗ Windows x64 publish failed[0m
)
echo.

REM Publish for Linux
echo Publishing for Linux (x64)...
dotnet publish EasySave/EasySave.csproj -c Release -r linux-x64 --self-contained false -o ./publish/linux-x64
if %ERRORLEVEL% EQU 0 (
    echo [32m✓ Linux x64 publish successful[0m
) else (
    echo [31m✗ Linux x64 publish failed[0m
)
echo.

REM Publish for macOS
echo Publishing for macOS (x64)...
dotnet publish EasySave/EasySave.csproj -c Release -r osx-x64 --self-contained false -o ./publish/osx-x64
if %ERRORLEVEL% EQU 0 (
    echo [32m✓ macOS x64 publish successful[0m
) else (
    echo [31m✗ macOS x64 publish failed[0m
)
echo.

echo ================================
echo Build completed successfully!
echo ================================
echo.
echo Published binaries available in .\publish\
echo   - Windows: .\publish\win-x64\
echo   - Linux:   .\publish\linux-x64\
echo   - macOS:   .\publish\osx-x64\
echo.
echo Note: These builds require .NET 8.0 Runtime to be installed on target systems
echo.
pause
</file>

<file path="build.sh">
#!/bin/bash

# EasySave V1.0 Build Script
# This script builds the EasySave project for multiple platforms

echo "================================"
echo "EasySave V1.0 Build Script"
echo "================================"
echo ""

# Check if dotnet is installed
if ! command -v dotnet &> /dev/null
then
    echo "Error: .NET SDK is not installed"
    echo "Please install .NET 8.0 SDK from https://dotnet.microsoft.com/download"
    exit 1
fi

echo "Checking .NET version..."
dotnet --version
echo ""

# Clean previous builds
echo "Cleaning previous builds..."
dotnet clean EasySave.sln
echo ""

# Restore dependencies
echo "Restoring NuGet packages..."
dotnet restore EasySave.sln
echo ""

# Build Debug configuration
echo "Building Debug configuration..."
dotnet build EasySave.sln -c Debug
if [ $? -eq 0 ]; then
    echo "✓ Debug build successful"
else
    echo "✗ Debug build failed"
    exit 1
fi
echo ""

# Build Release configuration
echo "Building Release configuration..."
dotnet build EasySave.sln -c Release
if [ $? -eq 0 ]; then
    echo "✓ Release build successful"
else
    echo "✗ Release build failed"
    exit 1
fi
echo ""

# Publish for Windows
echo "Publishing for Windows (x64)..."
dotnet publish EasySave/EasySave.csproj -c Release -r win-x64 --self-contained false -o ./publish/win-x64
if [ $? -eq 0 ]; then
    echo "✓ Windows x64 publish successful"
else
    echo "✗ Windows x64 publish failed"
fi
echo ""

# Publish for Linux
echo "Publishing for Linux (x64)..."
dotnet publish EasySave/EasySave.csproj -c Release -r linux-x64 --self-contained false -o ./publish/linux-x64
if [ $? -eq 0 ]; then
    echo "✓ Linux x64 publish successful"
else
    echo "✗ Linux x64 publish failed"
fi
echo ""

# Publish for macOS
echo "Publishing for macOS (x64)..."
dotnet publish EasySave/EasySave.csproj -c Release -r osx-x64 --self-contained false -o ./publish/osx-x64
if [ $? -eq 0 ]; then
    echo "✓ macOS x64 publish successful"
else
    echo "✗ macOS x64 publish failed"
fi
echo ""

echo "================================"
echo "Build completed successfully!"
echo "================================"
echo ""
echo "Published binaries available in ./publish/"
echo "  - Windows: ./publish/win-x64/"
echo "  - Linux:   ./publish/linux-x64/"
echo "  - macOS:   ./publish/osx-x64/"
echo ""
echo "Note: These builds require .NET 8.0 Runtime to be installed on target systems"
echo ""
</file>

<file path="EasyConsole/EasyConsole.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\EasySave\EasySave.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="EasyConsole/Program.cs">
using EasySave.Backup;
using EasyConsole.View;

namespace EasyConsole
{
    /// <summary>
    /// Main entry point of the EasySave application
    /// </summary>
    class Program
    {
        /// <summary>
        /// Main method of the project executed at the launch of the application.
        /// It initialize the console view and manages the global exception of the program.
        /// </summary>
        /// <param name="args">Array of arguments passed on the command line at the start of the application.</param>
        static void Main(string[] args)
        {
            // TODO: Retirer la ligne suivante
            var view = new ConsoleView();
            try
            {
                ConsoleView.Run(args);
            }
            catch (Exception e)
            {
                BackupManager.GetLogger().LogError(e);
            }
        }
    }
}
</file>

<file path="EasyGUI/app.manifest">
<?xml version="1.0" encoding="utf-8"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
  <!-- This manifest is used on Windows only.
       Don't remove it as it might cause problems with window transparency and embedded controls.
       For more details visit https://learn.microsoft.com/en-us/windows/win32/sbscs/application-manifests -->
  <assemblyIdentity version="1.0.0.0" name="EasyGUI.Desktop"/>

  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- A list of the Windows versions that this application has been tested on
           and is designed to work with. Uncomment the appropriate elements
           and Windows will automatically select the most compatible environment. -->

      <!-- Windows 10 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}" />
    </application>
  </compatibility>
</assembly>
</file>

<file path="EasyGUI/Program.cs">
using Avalonia;
using System;

namespace EasyGUI
{
    internal sealed class Program
    {
        // Initialization code. Don't use any Avalonia, third-party APIs or any
        // SynchronizationContext-reliant code before AppMain is called: things aren't initialized
        // yet and stuff might break.
        [STAThread]
        public static void Main(string[] args) => BuildAvaloniaApp()
            .StartWithClassicDesktopLifetime(args);

        // Avalonia configuration, don't remove; also used by visual designer.
        public static AppBuilder BuildAvaloniaApp()
            => AppBuilder.Configure<App>()
                .UsePlatformDetect()
                .WithInterFont()
                .LogToTrace();
    }
}
</file>

<file path="EasyGUI/Views/MainWindow.axaml.cs">
using Avalonia.Controls;

namespace EasyGUI.Views
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
        }
    }
}
</file>

<file path="EasyLog/Logging/Level.cs">
namespace EasyLog.Logging
{
	/// <summary>
	/// Specifies the severity level of a log message.
	/// </summary>
	/// <remarks>Use the Level enumeration to indicate the importance or urgency of a log entry. Higher levels, such
	/// as Error and Fatal, typically represent more severe issues that may require immediate attention, while Info and
	/// Debug are used for informational or diagnostic messages.</remarks>
	public enum Level
	{
		Info,
		Debug,
		Warning,
		Error,
		Fatal
	}
}
</file>

<file path="EasyLog/Logging/SimpleLogger.cs">
using EasyLog.Data;

namespace EasyLog.Logging
{
    /// <summary>
    /// Provides a simple file-based logger that writes log messages to a specified file in plain text format.
    /// </summary>
    /// <remarks>Log entries are appended to the file in a thread-safe manner. Each entry includes a
    /// timestamp, log level, and message. This logger is suitable for basic logging needs where structured or
    /// asynchronous logging is not required.</remarks>
    /// <param name="path">The file path where log entries will be written. If the file does not exist, it will be created.</param>
	public class SimpleLogger(string path) : AbstractLogger(path)
	{

        private readonly object _lock = new();

        public override string GetExtension() => "log";

        /// <summary>
        /// Writes a log entry with the specified severity level and message to the log file.
        /// </summary>
        /// <remarks>This method appends the log entry to the file specified by the Path property. The log
        /// entry includes a timestamp, the log level, and the message. This method is thread-safe.</remarks>
        /// <param name="level">The severity level of the log entry. Determines the importance or type of the log message.</param>
        /// <param name="message">The message to log. This value can be any string describing the event or information to record.</param>
        public override void Log(LogEntry message)
        {
            lock (_lock)
            {
				File.AppendAllText(LogFile, $"{message}\n");
			}
        }

    }
}
</file>

<file path="EasySave.sln">
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 18
VisualStudioVersion = 18.2.11415.280
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "EasySave", "EasySave\EasySave.csproj", "{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}"
	ProjectSection(ProjectDependencies) = postProject
		{77C2660F-95E0-48E2-A4AD-E8E83F69CCA6} = {77C2660F-95E0-48E2-A4AD-E8E83F69CCA6}
	EndProjectSection
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "EasyLog", "EasyLog\EasyLog.csproj", "{77C2660F-95E0-48E2-A4AD-E8E83F69CCA6}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "EasyTest", "EasyTest\EasyTest.csproj", "{AD53995A-45C8-4CDF-A5C7-0A27709BEB59}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "EasyConsole", "EasyConsole\EasyConsole.csproj", "{CED7224B-2F9C-431F-A137-65F324DFD29E}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{BD14BA82-EF3B-423C-9CF8-9707221DF76F}"
	ProjectSection(SolutionItems) = preProject
		.editorconfig = .editorconfig
	EndProjectSection
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "EasyGUI", "EasyGUI\EasyGUI.csproj", "{D27F9E92-6D52-4E95-AED5-AAC10A12AB61}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}.Release|Any CPU.Build.0 = Release|Any CPU
		{77C2660F-95E0-48E2-A4AD-E8E83F69CCA6}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{77C2660F-95E0-48E2-A4AD-E8E83F69CCA6}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{77C2660F-95E0-48E2-A4AD-E8E83F69CCA6}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{77C2660F-95E0-48E2-A4AD-E8E83F69CCA6}.Release|Any CPU.Build.0 = Release|Any CPU
		{AD53995A-45C8-4CDF-A5C7-0A27709BEB59}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{AD53995A-45C8-4CDF-A5C7-0A27709BEB59}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{AD53995A-45C8-4CDF-A5C7-0A27709BEB59}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{AD53995A-45C8-4CDF-A5C7-0A27709BEB59}.Release|Any CPU.Build.0 = Release|Any CPU
		{CED7224B-2F9C-431F-A137-65F324DFD29E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{CED7224B-2F9C-431F-A137-65F324DFD29E}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{CED7224B-2F9C-431F-A137-65F324DFD29E}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{CED7224B-2F9C-431F-A137-65F324DFD29E}.Release|Any CPU.Build.0 = Release|Any CPU
		{D27F9E92-6D52-4E95-AED5-AAC10A12AB61}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{D27F9E92-6D52-4E95-AED5-AAC10A12AB61}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{D27F9E92-6D52-4E95-AED5-AAC10A12AB61}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{D27F9E92-6D52-4E95-AED5-AAC10A12AB61}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {EA6BDC7D-939E-498D-928D-9487EF5794FE}
	EndGlobalSection
EndGlobal
</file>

<file path="EasySave/Backup/BackupStrategyFactory.cs">
namespace EasySave.Backup
{
	/// <summary>
	/// Factory for creating backup strategies (Factory Pattern)
	/// </summary>
	public class BackupStrategyFactory
	{

		private BackupStrategyFactory() {}

		/// <summary>
		/// Creates a backup strategy instance based on the specified backup type.
		/// </summary>
		/// <param name="type">The type of backup for which to create a strategy. Must be a defined value of the BackupType enumeration.</param>
		/// <returns>An instance of a class that implements the IBackupStrategy interface corresponding to the specified backup type.</returns>
		/// <exception cref="NotImplementedException">Thrown if the specified backup type is Incremental, which is not currently supported.</exception>
		/// <exception cref="ArgumentException">Thrown if the specified backup type is not recognized.</exception>
		public static IBackupStrategy CreateStrategy(BackupType type)
		{
			return type switch
			{
				BackupType.Complete     => new CompleteBackupStrategy(),
				BackupType.Differential => new DifferentialBackupStrategy(),
				BackupType.Incremental  => throw new NotImplementedException("This backup type is not yet implemented!"),
				_ => throw new ArgumentException($"Unknown backup type: {type}")
			};
		}
	}
}
</file>

<file path="EasySave/Backup/BackupType.cs">
namespace EasySave.Backup
{
	/// <summary>
	/// Backup job types
	/// </summary>
	public enum BackupType
	{
		Complete,
		Differential,
		Incremental
	}
}
</file>

<file path="EasySave/Backup/State.cs">
namespace EasySave.Backup
{
	/// <summary>
	/// Backup job state
	/// </summary>
	public enum State
	{
		Inactive,
		Active,
		Completed,
		Error
	}
}
</file>

<file path="EasySave/ClassDiagram.cd">
<?xml version="1.0" encoding="utf-8"?>
<ClassDiagram MajorVersion="1" MinorVersion="1" MembersFormat="FullSignature">
  <Class Name="EasySave.Backup.BackupStrategyFactory">
    <Position X="9.5" Y="16.5" Width="3.5" />
    <TypeIdentifier>
      <HashCode>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAA=</HashCode>
      <FileName>Backup\BackupStrategyFactory.cs</FileName>
    </TypeIdentifier>
  </Class>
  <Class Name="EasySave.Backup.CompleteBackupStrategy" BaseTypeListCollapsed="true">
    <Position X="8.75" Y="18" Width="4.75" />
    <TypeIdentifier>
      <HashCode>AAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAA=</HashCode>
      <FileName>Backup\CompleteBackupStrategy.cs</FileName>
    </TypeIdentifier>
    <Lollipop Position="0.2" Collapsed="true" />
  </Class>
  <Class Name="EasySave.Backup.DifferentialBackupStrategy" BaseTypeListCollapsed="true">
    <Position X="8.75" Y="19.5" Width="4.75" />
    <TypeIdentifier>
      <HashCode>AAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAA=</HashCode>
      <FileName>Backup\DifferentialBackupStrategy.cs</FileName>
    </TypeIdentifier>
    <Lollipop Position="0.2" Collapsed="true" />
  </Class>
  <Class Name="EasySave.Backup.ProgressState">
    <Position X="4.25" Y="14" Width="3" />
    <TypeIdentifier>
      <HashCode>AAAgACAAAAAAAgAAKAACEAAAAAAAAAAAAIAABAIAAAA=</HashCode>
      <FileName>Backup\ProgressState.cs</FileName>
    </TypeIdentifier>
  </Class>
  <Class Name="EasySave.Extensions.ConsoleExt">
    <Position X="3.5" Y="7.5" Width="1.5" />
    <TypeIdentifier>
      <HashCode>AAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAA=</HashCode>
      <FileName>Extensions\ConsoleExt.cs</FileName>
    </TypeIdentifier>
  </Class>
  <Class Name="EasySave.Logger.AbstractLogger">
    <Position X="0.5" Y="2.5" Width="2.75" />
    <TypeIdentifier>
      <HashCode>AAAAAAAAAAAAAAIAAAAAAAAAIAgAAAAAAAAGAAAAAAA=</HashCode>
      <FileName>Logger\AbstractLogger.cs</FileName>
    </TypeIdentifier>
    <Lollipop Position="0.2" />
  </Class>
  <Class Name="EasySave.Logger.SimpleLogger">
    <Position X="0.5" Y="5.75" Width="2.75" />
    <TypeIdentifier>
      <HashCode>AAAAAAAAAAAAAAAgAAAAAAAAIAgAAAAAAAAAAAAAAAA=</HashCode>
      <FileName>Logger\SimpleLogger.cs</FileName>
    </TypeIdentifier>
  </Class>
  <Class Name="EasySave.Utils.ConfigurationManager">
    <Position X="4.25" Y="11" Width="3.25" />
    <TypeIdentifier>
      <HashCode>AAAAAAAAAAAAAAIEUAAEAAAAAAAAAAAABAAAAAAAAAA=</HashCode>
      <FileName>Utils\ConfigurationManager.cs</FileName>
    </TypeIdentifier>
  </Class>
  <Class Name="EasySave.Utils.ResourceManager">
    <Position X="3.5" Y="6" Width="3.25" />
    <TypeIdentifier>
      <HashCode>AAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAA=</HashCode>
      <FileName>Utils\ResourceManager.cs</FileName>
    </TypeIdentifier>
  </Class>
  <Class Name="EasySave.Utils.StateWriter">
    <Position X="14.5" Y="7.75" Width="3.5" />
    <TypeIdentifier>
      <HashCode>AAAAEAAAAgAAACBgAAAAAAAAAAAAAAAAAAAABAAAAAA=</HashCode>
      <FileName>Utils\StateWriter.cs</FileName>
    </TypeIdentifier>
  </Class>
  <Class Name="EasySave.View.Command.CommandContext">
    <Position X="13.25" Y="4" Width="3" />
    <TypeIdentifier>
      <HashCode>AIAEAAAAAAAAAAAAAQAAAAAAAAAAAAAAQAAAAAAAAAg=</HashCode>
      <FileName>View\Command\CommandContext.cs</FileName>
    </TypeIdentifier>
  </Class>
  <Class Name="EasySave.View.Commands.CreateBackupJobCommand" BaseTypeListCollapsed="true">
    <Position X="17" Y="4.5" Width="2.25" />
    <TypeIdentifier>
      <HashCode>AAAAAAAAAAAAAAQAAAAAgAAAAAAAAAAAAAAAAAAAAAA=</HashCode>
      <FileName>View\Commands\CreateBackupJobCommand.cs</FileName>
    </TypeIdentifier>
    <Lollipop Position="0.2" Collapsed="true" />
  </Class>
  <Class Name="EasySave.View.Commands.ExecuteBackupJobCommand" BaseTypeListCollapsed="true">
    <Position X="17" Y="3" Width="2.25" />
    <TypeIdentifier>
      <HashCode>AAAAAAAAAAAAAAQAAAAAgAAAAAAAAAAAAAAAAAAAAAA=</HashCode>
      <FileName>View\Commands\ExecuteBackupJobCommand.cs</FileName>
    </TypeIdentifier>
    <Lollipop Position="0.2" Collapsed="true" />
  </Class>
  <Class Name="EasySave.View.Localization.I18n">
    <Position X="3.5" Y="2.5" Width="5" />
    <TypeIdentifier>
      <HashCode>AAAEAAAACAIAAAQAAAACBEAAAAAAAAAAQAAAAAAACAA=</HashCode>
      <FileName>View\Localization\I18n.cs</FileName>
    </TypeIdentifier>
  </Class>
  <Class Name="EasySave.View.ConsoleView">
    <Position X="9.25" Y="4" Width="3.25" />
    <TypeIdentifier>
      <HashCode>AAkAAAAAAAAAAAAAAAAAAFgBAAAAAAAABEAAQAAEAAI=</HashCode>
      <FileName>View\ConsoleView.cs</FileName>
    </TypeIdentifier>
  </Class>
  <Class Name="EasySave.Program">
    <Position X="9.75" Y="2.5" Width="2" />
    <TypeIdentifier>
      <HashCode>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAA=</HashCode>
      <FileName>Program.cs</FileName>
    </TypeIdentifier>
  </Class>
  <Class Name="EasySave.Backup.BackupManager">
    <Position X="8" Y="7.75" Width="6" />
    <TypeIdentifier>
      <HashCode>CAAEAAAAgCAAAAAgAAgAAgAAIAgAAJAJADAEAAAAAIA=</HashCode>
      <FileName>Backup\BackupManager.cs</FileName>
    </TypeIdentifier>
  </Class>
  <Class Name="EasySave.Backup.BackupJob">
    <Position X="8.5" Y="12.75" Width="5.25" />
    <TypeIdentifier>
      <HashCode>AAACAAAAAAAAAQQAggAAAAQIAAAAAAAAAQAABBAAAAA=</HashCode>
      <FileName>Backup\BackupJob.cs</FileName>
    </TypeIdentifier>
  </Class>
  <Interface Name="EasySave.Backup.IBackupStrategy">
    <Position X="3.5" Y="0.5" Width="4.75" />
    <TypeIdentifier>
      <HashCode>AAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAA=</HashCode>
      <FileName>Backup\IBackupStrategy.cs</FileName>
    </TypeIdentifier>
  </Interface>
  <Interface Name="EasySave.Logger.ILogger">
    <Position X="0.5" Y="0.5" Width="2.75" />
    <TypeIdentifier>
      <HashCode>AAAAAAAAAAAAAAAAAAAAAAAAIAgAAAAAAAAAAAAAAAA=</HashCode>
      <FileName>Logger\ILogger.cs</FileName>
    </TypeIdentifier>
  </Interface>
  <Interface Name="EasySave.View.Command.ICommand">
    <Position X="8.5" Y="0.5" Width="1.5" />
    <TypeIdentifier>
      <HashCode>AAAAAAAAAAAAAAQAAAAAgAAAAAAAAAAAAAAAAAAAAAA=</HashCode>
      <FileName>View\Command\ICommand.cs</FileName>
    </TypeIdentifier>
  </Interface>
  <Enum Name="EasySave.Backup.BackupType">
    <Position X="3.5" Y="9.25" Width="1.5" />
    <TypeIdentifier>
      <HashCode>AAAAAAAAAAAAAgIAAAAAAAAAAAAAAAAAAAQAAAAAAAA=</HashCode>
      <FileName>Backup\BackupType.cs</FileName>
    </TypeIdentifier>
  </Enum>
  <Enum Name="EasySave.Backup.State">
    <Position X="5.5" Y="7.5" Width="1.5" />
    <TypeIdentifier>
      <HashCode>AAAACAAAAAAAAQIAAAAAAAAAAAAAAAAgAAAAAAAAAAA=</HashCode>
      <FileName>Backup\State.cs</FileName>
    </TypeIdentifier>
  </Enum>
  <Enum Name="EasySave.Logger.Level">
    <Position X="1" Y="8" Width="1.5" />
    <TypeIdentifier>
      <HashCode>AAAAAAAAAAAAAYAAAAAAABAAAAAAAAAAAAAAAEAEAAA=</HashCode>
      <FileName>Logger\Level.cs</FileName>
    </TypeIdentifier>
  </Enum>
  <Font Name="Segoe UI" Size="9" />
</ClassDiagram>
</file>

<file path="EasySave/global.json">
{
  "sdk": {
    "version": "8.0.417"
  }
}
</file>

<file path="EasySave/Properties/launchSettings.json">
{
  "profiles": {
    "EasySave": {
      "commandName": "Project"
    }
  }
}
</file>

<file path="EasySave/Properties/PublishProfiles/FolderProfile.pubxml">
<?xml version="1.0" encoding="utf-8"?>
<!-- https://go.microsoft.com/fwlink/?LinkID=208121. -->
<Project>
  <PropertyGroup>
    <Configuration>Release</Configuration>
    <Platform>Any CPU</Platform>
    <PublishDir>bin\Release\net8.0\win-x64\publish\</PublishDir>
    <PublishProtocol>FileSystem</PublishProtocol>
    <_TargetId>Folder</_TargetId>
    <TargetFramework>net8.0</TargetFramework>
    <RuntimeIdentifier>win-x64</RuntimeIdentifier>
    <SelfContained>false</SelfContained>
  </PropertyGroup>
</Project>
</file>

<file path="EasySave/Utils/ResourceManager.cs">
using System.Reflection;

namespace EasySave.Utils
{
	/// <summary>
	/// Provides methods for reading embedded resource files from the assembly.
	/// </summary>
    public class ResourceManager
    {
		/// <summary>
		/// Initializes a new instance of the ResourceManager class.
		/// </summary>
        private ResourceManager() { }

		/// <summary>
		/// Reads the contents of an embedded resource file from the executing assembly.
		/// </summary>
		/// <remarks>Resource names are case-sensitive and must match the names used when embedding the resources in
		/// the assembly. This method is typically used to access files such as configuration data or templates that are
		/// included as embedded resources.</remarks>
		/// <param name="resourceName">The name of the embedded resource to read. If the name does not begin with "EasySave.", the prefix is
		/// automatically added.</param>
		/// <returns>A string containing the full contents of the specified embedded resource file.</returns>
		/// <exception cref="FileNotFoundException">Thrown if the specified resource cannot be found in the executing assembly.</exception>
		public static string ReadResourceFile(string resourceName)
        {
			var assembly = Assembly.GetExecutingAssembly();
			if (!resourceName.StartsWith("EasySave."))
				resourceName = "EasySave." + resourceName;
			using Stream? stream = assembly.GetManifestResourceStream(resourceName) ?? throw new FileNotFoundException($"Unavailable resource: {resourceName}");
            using var reader = new StreamReader(stream);
			return reader.ReadToEnd();
		}
	}
}
</file>

<file path="EasySave/Utils/StateWriter.cs">
using EasySave.Backup;
using Newtonsoft.Json;

namespace EasySave.Utils
{
    /// <summary>
    /// Writes real-time state information to a JSON file
    /// </summary>
    public class StateWriter
    {
        private readonly string _stateFilePath;
        private readonly object _lockObject = new();
        private Dictionary<string, ProgressState> _currentStates = [];

        public StateWriter(string stateDirectory)
        {
            if (!Directory.Exists(stateDirectory))
            {
                Directory.CreateDirectory(stateDirectory);
            }

            _stateFilePath = Path.Combine(stateDirectory, "state.json");
        }

        /// <summary>
        /// Updates the progress state for a specific backup operation.
        /// </summary>
        /// <remarks>This method is thread-safe. The updated state is persisted to storage after the
        /// operation completes.</remarks>
        /// <param name="state">The new progress state to associate with the backup. Cannot be null. The <see
        /// cref="ProgressState.BackupName"/> property is used to identify which backup's state to update.</param>
        public void UpdateState(ProgressState state)
        {
            lock (_lockObject)
            {
                _currentStates[state.BackupName] = state;
                WriteStatesToFile();
            }
        }

        /// <summary>
        /// Removes the backup state associated with the specified backup name.
        /// </summary>
        /// <remarks>If the specified backup name does not exist, no action is taken. This method is
        /// thread-safe.</remarks>
        /// <param name="backupName">The name of the backup whose state should be removed. Cannot be null.</param>
        public void RemoveState(string backupName)
        {
            lock (_lockObject)
            {
                if (_currentStates.ContainsKey(backupName))
                {
                    _currentStates.Remove(backupName);
                    WriteStatesToFile();
                }
            }
        }

        /// <summary>
        /// Writes the current collection of progress states to a file in JSON format.
        /// </summary>
        /// <remarks>This method overwrites the existing file at the specified path with the latest
        /// progress state data. The file path and the collection of states must be properly initialized before calling
        /// this method.</remarks>
        private void WriteStatesToFile()
        {
            var statesList = new List<ProgressState>(_currentStates.Values);
            string jsonContent = JsonConvert.SerializeObject(statesList, Formatting.Indented);
            File.WriteAllText(_stateFilePath, jsonContent);
        }
    }
}
</file>

<file path="EasyConsole/View/Command/CommandContext.cs">
using EasyConsole.View.Commands;
using EasySave.View.Localization;

namespace EasyConsole.View.Command
{
    /// <summary>
    /// Context class for the Command pattern implementation.
    /// It manages the registration, display, and execution of available console commands.
    /// </summary>
    public class CommandContext
    {

        private static CommandContext? _instance;

        /// <summary>
        /// Gets the unique instance of the CommandContext (Singleton pattern).
        /// </summary>
        public static CommandContext Instance
        {
            get
            {
                _instance ??= new CommandContext();
                return _instance;
            }
        }

        private readonly Dictionary<int, ICommand> commandList;

        /// <summary>
        /// Initializes a new instance of the CommandContext class.
        /// Private constructor to enforce Singleton pattern and initialize the command list.
        /// </summary>
        private CommandContext()
        {
            commandList = [];
            InitCommands();
        }

        /// <summary>
        /// Initializes the list of available commands and registers them in the dictionary.
        /// </summary>
        private void InitCommands()
        {
            ICommand[] commands = [
                new CreateBackupJobCommand(),
                new ExecuteBackupJobCommand(),
                new ExecuteAllBackupJobsCommand(),
                new ListBackupJobsCommand(),
                new DeleteBackupJobCommand(),
                new ChangeLanguageCommand(),
                new ExitCommand(),
            ];

            foreach (var command in commands)
                this.commandList[command.GetID()] = command;
        }

        /// <summary>
        /// Executes the command associated with the specified identifier.
        /// </summary>
        /// <param name="id">The unique identifier of the command to execute.</param>
        /// <returns>True if the command was found and executed; otherwise, false.</returns>
        public bool ExecuteCommand(int id)
        {
            if (this.commandList.TryGetValue(id, out ICommand? command))
            {
                if (command == null)
                    return false;
                command.Execute();
                return true;
            }
            return false;
        }

        /// <summary>
        /// Displays the main menu with the list of available commands to the console.
        /// </summary>
        public void DisplayCommands()
        {
            Console.Clear();
            Console.WriteLine("=== {0} ===", I18n.Instance.GetString("menu_title"));
            Console.WriteLine();

            foreach (var command in this.commandList)
                Console.WriteLine("{0}. {1}", command.Key, I18n.Instance.GetString(command.Value.GetI18nKey()));

            Console.WriteLine();
            Console.Write("{0}: ", I18n.Instance.GetString("menu_choice"));
        }

    }
}
</file>

<file path="EasyConsole/View/Command/ICommand.cs">
namespace EasyConsole.View.Command
{
    /// <summary>
    /// Interface defining the structure of a command in the application.
    /// Implements the Command pattern to encapsulate user actions.
    /// </summary>
    public interface ICommand
    {
        /// <summary>
        /// Gets the unique identifier of the command.
        /// This ID is used to map user input to the specific command in the menu.
        /// </summary>
        /// <returns>The unique integer identifier of the command.</returns>
        int GetID();

        /// <summary>
        /// Gets the localization key for the command's display name.
        /// </summary>
        /// <returns>The string key used to retrieve the localized description.</returns>
        string GetI18nKey();

        /// <summary>
        /// Executes the specific logic associated with the command.
        /// </summary>
        void Execute();

    }
}
</file>

<file path="EasyConsole/View/Commands/ChangeLanguageCommand.cs">
using EasySave.Extensions;
using EasyConsole.View.Command;
using EasySave.View.Localization;

namespace EasyConsole.View.Commands
{
    /// <summary>
    /// Command to change the application's interface language.
    /// </summary>
    public class ChangeLanguageCommand : ICommand
    {

        /// <summary>
        /// Gets the localization key for the "Change language" menu item.
        /// </summary>
        /// <returns>The string key "menu_language".</returns>
        public string GetI18nKey() => "menu_language";

        /// <summary>
        /// Gets the unique identifier for the change language command.
        /// </summary>
        /// <returns>The integer ID 6.</returns>
        public int GetID() => 6;

        /// <summary>
        /// Executes the language change workflow.
        /// </summary>
        /// <remarks>
        /// This method displays the list of available languages loaded from resources,
        /// prompts the user to select one, and updates the global I18n configuration.
        /// </remarks>
        public void Execute()
        {
            Console.Clear();
            Console.WriteLine("{0}: ", I18n.Instance.GetString("language_select"));
            var langProperties = I18n.Instance.LoadLanguagesProperties();
            int i = 0;
            foreach (var lang in langProperties)
            {
                Console.WriteLine("{0} - {1}", ++i, lang.Value["@language_name"]);
            }
            var choice = ConsoleExt.ReadDec();

            i = 0;
            foreach (var lang in langProperties)
            {
                i++;
                if (i == choice)
                {
                    I18n.Instance.SetLanguage(lang.Key);
                    Console.WriteLine(I18n.Instance.GetString("language_changed"));
                    break;
                }
            }
            //_ = Console.ReadKey();
        }
    }
}
</file>

<file path="EasyConsole/View/Commands/CreateBackupJobCommand.cs">
using EasySave.Backup;
using EasySave.Extensions;
using EasyConsole.View.Command;
using EasySave.View.Localization;

namespace EasyConsole.View.Commands
{
    /// <summary>
    /// Command to create a new backup job.
    /// Handles user input for job details and registers the job via the BackupManager.
    /// </summary>
    public class CreateBackupJobCommand : ICommand
    {

        /// <summary>
        /// Gets the unique identifier for the create backup job command.
        /// </summary>
        /// <returns>The integer ID 1.</returns>
        public int GetID() => 1;

        /// <summary>
        /// Executes the workflow for creating a new backup job.
        /// </summary>
        /// <remarks>
        /// This method prompts the user for the backup job name, source directory,
        /// target directory, and backup type (Complete or Differential).
        /// It then attempts to add the job to the BackupManager and displays a success or failure message.
        /// </remarks>
        public void Execute()
        {
            Console.Clear();
            Console.Write("{0}: ", I18n.Instance.GetString("create_name"));
            string? name = Console.ReadLine();

            Console.Write("{0}: ", I18n.Instance.GetString("create_source"));
            string? source = Console.ReadLine();

            Console.Write("{0}: ", I18n.Instance.GetString("create_target"));
            string? target = Console.ReadLine();

            Console.Write("{0}: ", I18n.Instance.GetString("create_type"));
            int typeChoice = ConsoleExt.ReadDec();

            BackupType type = typeChoice == 2 ? BackupType.Differential : BackupType.Complete;
            string key = BackupManager.GetBM().AddJob(name, source, target, type) ? "success" : "failure";
            Console.WriteLine(I18n.Instance.GetString($"create_{key}"));
        }

        /// <summary>
        /// Gets the localization key for the "Create backup job" menu item.
        /// </summary>
        /// <returns>The string key "menu_create".</returns>
        public string GetI18nKey() => "menu_create";
    }
}
</file>

<file path="EasyConsole/View/Commands/DeleteBackupJobCommand.cs">
using EasySave.Backup;
using EasyConsole.View.Command;
using EasySave.View.Localization;

namespace EasyConsole.View.Commands
{
    /// <summary>
    /// Command to delete an existing backup job.
    /// </summary>
    public class DeleteBackupJobCommand : ICommand
    {

        /// <summary>
        /// Gets the localization key for the "Delete backup job" menu item.
        /// </summary>
        /// <returns>The string key "menu_delete".</returns>
        public string GetI18nKey() => "menu_delete";

        /// <summary>
        /// Gets the unique identifier for the delete backup job command.
        /// </summary>
        /// <returns>The integer ID 5.</returns>
        public int GetID() => 5;

        /// <summary>
        /// Executes the workflow for deleting a backup job.
        /// </summary>
        /// <remarks>
        /// This method clears the console, displays the list of existing backup jobs
        /// (by invoking the List command), prompts the user for the ID of the job to delete,
        /// and attempts to remove it via the BackupManager.
        /// </remarks>
        public void Execute()
        {
            Console.Clear();

            // Afficher la liste des processus de sauvegarde
            CommandContext.Instance.ExecuteCommand(4);

            Console.Write("{0}: ", I18n.Instance.GetString("delete_id"));

            if (int.TryParse(Console.ReadLine(), out int id))
            {
                string key = BackupManager.GetBM().DeleteJob(id) ? "success" : "failure";
                Console.WriteLine(I18n.Instance.GetString($"delete_{key}"));
            }
        }
    }
}
</file>

<file path="EasyConsole/View/Commands/ExecuteAllBackupJobsCommand.cs">
using EasySave.Backup;
using EasyConsole.View.Command;
using EasySave.View.Localization;

namespace EasyConsole.View.Commands
{
    /// <summary>
    /// Command to execute all configured backup jobs sequentially.
    /// </summary>
    public class ExecuteAllBackupJobsCommand : ICommand
    {
        /// <summary>
        /// Executes the workflow for running all backup jobs.
        /// </summary>
        /// <remarks>
        /// This method clears the console, notifies the user that execution is starting,
        /// and triggers the execution of all jobs via the BackupManager.
        /// It uses the ConsoleView.DisplayProgress method to show real-time progress.
        /// </remarks>
        public void Execute()
        {
            Console.Clear();
            Console.WriteLine(I18n.Instance.GetString("execute_all_start"));

            try
            {
                BackupManager.GetBM().ExecuteAllJobs(ConsoleView.DisplayProgress);
                Console.WriteLine(I18n.Instance.GetString("execute_success"));
            }
            catch (Exception e)
            {
                Console.WriteLine(I18n.Instance.GetString("execute_failure") + e.Message);
            }
        }

        /// <summary>
        /// Gets the localization key for the "Execute all backup jobs" menu item.
        /// </summary>
        /// <returns>The string key "menu_execute_all".</returns>
        public string GetI18nKey() => "menu_execute_all";


        /// <summary>
        /// Gets the unique identifier for the execute all jobs command.
        /// </summary>
        /// <returns>The integer ID 3.</returns>
        public int GetID() => 3;
    }
}
</file>

<file path="EasyConsole/View/Commands/ExitCommand.cs">
using EasySave.Backup;
using EasyConsole.View.Command;

namespace EasyConsole.View.Commands
{
    /// <summary>
    /// Command to exit the application.
    /// </summary>
    public class ExitCommand : ICommand
    {
        /// <summary>
        /// Gets the localization key for the "Exit" menu item.
        /// </summary>
        /// <returns>The string key "menu_exit".</returns>
        public string GetI18nKey() => "menu_exit";

        /// <summary>
        /// Gets the unique identifier for the exit command.
        /// </summary>
        /// <returns>The integer ID 7.</returns>
        public int GetID() => 7;

        /// <summary>
        /// Executes the exit workflow.
        /// </summary>
        /// <remarks>
        /// This method transmits an Exit signal to the BackupManager, 
        /// allowing the application to terminate the main execution loop gracefully.
        /// </remarks>
        public void Execute()
        {
            BackupManager.GetBM().TransmitSignal(Signal.Exit);
        }
    }
}
</file>

<file path="EasyConsole/View/Commands/ListBackupJobsCommand.cs">
using EasySave.Backup;
using EasySave.Extensions;
using EasyConsole.View.Command;
using EasySave.View.Localization;

namespace EasyConsole.View.Commands
{
    /// <summary>
    /// Command to list all configured backup jobs.
    /// </summary>
    public class ListBackupJobsCommand : ICommand
    {
        /// <summary>
        /// Executes the workflow for listing backup jobs.
        /// </summary>
        /// <remarks>
        /// This method retrieves the list of jobs from the BackupManager.
        /// If no jobs exist, it displays an empty list message.
        /// Otherwise, it iterates through the jobs and prints their details (ID, Name, Source, Target, Type, State, Last Execution) to the console.
        /// </remarks>
        public void Execute()
        {
            Console.WriteLine("=== {0} ===", I18n.Instance.GetString("list_title"));

            var jobs = BackupManager.GetBM().GetAllJobs();

            if (jobs.Count == 0)
            {
                Console.WriteLine(I18n.Instance.GetString("list_empty"));
                return;
            }

            foreach (var job in jobs)
            {
                Console.WriteLine("{0}: {1}", I18n.Instance.GetString("list_id"), job.Id);
                Console.WriteLine("{0}: {1}", I18n.Instance.GetString("list_name"), job.Name);
                Console.WriteLine("{0}: {1}", I18n.Instance.GetString("list_source"), job.SourceDirectory);
                Console.WriteLine("{0}: {1}", I18n.Instance.GetString("list_target"), job.TargetDirectory);
                Console.WriteLine("{0}: {1}", I18n.Instance.GetString("list_type"), job.Type.GetTranslation());
                Console.WriteLine("{0}: {1}", I18n.Instance.GetString("list_state"), job.State.GetTranslation());
                Console.WriteLine("{0}: {1}", I18n.Instance.GetString("list_last_exec"), job.LastExecution.ToString("yyyy-MM-dd HH:mm:ss") ?? I18n.Instance.GetString("never"));
            }
        }

        /// <summary>
        /// Gets the localization key for the "List backup jobs" menu item.
        /// </summary>
        /// <returns>The string key "menu_list".</returns>
        public string GetI18nKey() => "menu_list";


        /// <summary>
        /// Gets the unique identifier for the list backup jobs command.
        /// </summary>
        /// <returns>The integer ID 4.</returns>
        public int GetID() => 4;
    }
}
</file>

<file path="EasyGUI/App.axaml.cs">
using Avalonia;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Data.Core.Plugins;
using Avalonia.Markup.Xaml;
using EasyGUI.Views;
using EasyGUI.ViewModels;
using System.Linq;

namespace EasyGUI
{
    public partial class App : Application
    {
        public override void Initialize()
        {
            AvaloniaXamlLoader.Load(this);
        }

        public override void OnFrameworkInitializationCompleted()
        {
            if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
            {
                DisableAvaloniaDataAnnotationValidation();
                desktop.MainWindow = new MainWindow
                {
                    DataContext = new MainWindowViewModel(),
                };
            }

            base.OnFrameworkInitializationCompleted();
        }

        private void DisableAvaloniaDataAnnotationValidation()
        {
            // Get an array of plugins to remove
            var dataValidationPluginsToRemove = BindingPlugins.DataValidators.OfType<DataAnnotationsValidationPlugin>().ToArray();

            // remove each entry found
            foreach (var plugin in dataValidationPluginsToRemove)
            {
                BindingPlugins.DataValidators.Remove(plugin);
            }
        }
    }
}
</file>

<file path="EasyGUI/EasyGUI.csproj">
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ApplicationManifest>app.manifest</ApplicationManifest>
    <AvaloniaUseCompiledBindingsByDefault>true</AvaloniaUseCompiledBindingsByDefault>
  </PropertyGroup>

  <ItemGroup>
    <AvaloniaResource Include="Assets\**" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Avalonia" Version="11.3.11" />
    <PackageReference Include="Avalonia.Desktop" Version="11.3.11" />
    <PackageReference Include="Avalonia.Themes.Fluent" Version="11.3.11" />
    <PackageReference Include="Avalonia.Fonts.Inter" Version="11.3.11" />
    <!--Condition below is needed to remove Avalonia.Diagnostics package from build output in Release configuration.-->
    <PackageReference Include="Avalonia.Diagnostics" Version="11.3.11">
      <IncludeAssets Condition="'$(Configuration)' != 'Debug'">None</IncludeAssets>
      <PrivateAssets Condition="'$(Configuration)' != 'Debug'">All</PrivateAssets>
    </PackageReference>
    <PackageReference Include="CommunityToolkit.Mvvm" Version="8.2.1" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\EasyLog\EasyLog.csproj" />
    <ProjectReference Include="..\EasySave\EasySave.csproj" />
  </ItemGroup>
</Project>
</file>

<file path="EasyGUI/ViewLocator.cs">
using Avalonia.Controls;
using Avalonia.Controls.Templates;
using CommunityToolkit.Mvvm.ComponentModel;
using System;
using System.Diagnostics.CodeAnalysis;

namespace EasyGUI
{
    /// <summary>
    /// Given a view model, returns the corresponding view if possible.
    /// </summary>
    [RequiresUnreferencedCode(
        "Default implementation of ViewLocator involves reflection which may be trimmed away.",
        Url = "https://docs.avaloniaui.net/docs/concepts/view-locator")]
    public class ViewLocator : IDataTemplate
    {
        public Control? Build(object? param)
        {
            if (param is null)
                return null;

            var name = param.GetType().FullName!.Replace("ViewModel", "View", StringComparison.Ordinal);
            var type = Type.GetType(name);

            if (type != null)
            {
                return (Control)Activator.CreateInstance(type)!;
            }

            return new TextBlock { Text = "Not Found: " + name };
        }

        public bool Match(object? data)
        {
            return data is ObservableObject;
        }
    }
}
</file>

<file path="EasyLog/EasyLog.csproj">
<Project Sdk="Microsoft.NET.Sdk">
	
	<PropertyGroup>
		<TargetFramework>net8.0</TargetFramework>
		<ImplicitUsings>enable</ImplicitUsings>
		<Nullable>enable</Nullable>
	</PropertyGroup>
	
</Project>
</file>

<file path="EasyLog/Logging/AbstractLogger.cs">
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using EasyLog.Data;

namespace EasyLog.Logging
{
	/// <summary>
	/// Provides a base implementation for loggers that write log entries to a file system path.
	/// </summary>
	/// <remarks>This abstract class defines common functionality for file-based loggers, including directory
	/// initialization and file path management. Derived classes must implement the logging methods to specify how log
	/// entries are written. This class is not intended to be used directly; instead, inherit from it to create a custom
	/// logger.</remarks>
	public abstract class AbstractLogger : ILogger
	{

		private readonly string _path;

		public string LogFile { get; private set; }

		public AbstractLogger(string path)
		{
			this._path = path;
			if (!Directory.Exists(path))
				Directory.CreateDirectory(path);
			LogFile = this.GetFile();
		}

		/// <summary>
		/// Generates the full file path for the log file corresponding to the current date.
		/// </summary>
		/// <returns>A string containing the absolute path to the log file for today, with the file name formatted as "yyyy-MM-dd.log".</returns>
		public string GetFile() => Path.Combine(_path, $"{DateTime.Now:yyyy-MM-dd}." + GetExtension());

		public abstract string GetExtension();

		/// <summary>
		/// Writes a log entry with the specified severity level and message.
		/// </summary>
		/// <param name="level">The severity level of the log entry. Determines the importance and filtering of the log message.</param>
		/// <param name="message">The message to log. Cannot be null.</param>
		public abstract void Log(LogEntry message);

	}
}
</file>

<file path="EasyLog/Logging/ILogger.cs">
using EasyLog.Data;

namespace EasyLog.Logging
{

	/// <summary>
	/// Interface for logging implementations
	/// </summary>
	public interface ILogger
	{

		/// <summary>
		/// Logs a transfer operation
		/// </summary>
		void Log(LogEntry message);

		/// <summary>
		/// Logs the specified exception as an error entry to the log file.
		/// </summary>
		/// <remarks>The error message and stack trace are both written to the log file. This method is
		/// thread-safe.</remarks>
		/// <param name="e">The exception to log.</param>
		virtual void LogError(Exception e) => Log(new LogEntry { Level = Level.Error, Message = e.Message, Stacktrace = e.StackTrace });
		
	}
}
</file>

<file path="EasySave/Backup/Signal.cs">
namespace EasySave.Backup
{
    /// <summary>
    /// Represents control signals used to manage the application's flow and state.
    /// </summary>
    public enum Signal
    {
        /// <summary>
        /// No active signal or default state.
        /// </summary>
        None,

        /// <summary>
        /// Signal to continue normal execution or resume operations.
        /// </summary>
        Continue,

        /// <summary>
        /// Signal to terminate the application or stop the current process.
        /// </summary>
        Exit
    }
}
</file>

<file path="EasySave/Extensions/ConsoleExt.cs">
namespace EasySave.Extensions
{
    /// <summary>
    /// Provides helper methods for console interactions, specifically for reading and parsing user input.
    /// </summary>
    public static class ConsoleExt
    {

        /// <summary>
        /// Reads a line of text from the console and converts it to an integer.
        /// </summary>
        /// <returns>The integer representation of the user's input.</returns>
        /// <exception cref="FormatException">Thrown if the input is not a valid integer.</exception>
        public static int ReadDec()
        {
            if (int.TryParse(Console.ReadLine(), out int dec))
                return dec;
            throw new FormatException("Not an int!");
        }

    }
}
</file>

<file path="EasyTest/BackupManagerTests.cs">
using EasySave.Backup;

[assembly: DoNotParallelize]

namespace EasyTest
{
    [TestClass]
    public class BackupManagerTests
    {
        [TestInitialize]
        public void Setup()
        {
            var bm = BackupManager.GetBM();
            var jobs = bm.GetAllJobs();
            foreach (var job in jobs)
            {
                bm.DeleteJob(job.Id);
            }
        }

        [TestMethod]
        public void TestAjoutTravail_Succes()
        {
            var bm = BackupManager.GetBM();

            bool resultat = bm.AddJob("TravailTest", @"C:\Source", @"C:\Cible", BackupType.Complete);

            Assert.IsTrue(resultat, "Le travail aurait dû être ajouté avec succès.");
            Assert.AreEqual(1, bm.GetAllJobs().Count, "Il devrait y avoir exactement 1 travail dans la liste.");
            Assert.AreEqual("TravailTest", bm.GetAllJobs()[0].Name);
        }

        [TestMethod]
        public void TestAjoutTravail_Echec_CheminsInvalides()
        {
            var bm = BackupManager.GetBM();

            bool resultat = bm.AddJob("", "", "", BackupType.Complete);

            Assert.IsFalse(resultat, "Le travail ne doit pas être créé avec des chemins vides.");
            Assert.AreEqual(0, bm.GetAllJobs().Count);
        }

        [TestMethod]
        public void TestSuppressionTravail_Succes()
        {
            var bm = BackupManager.GetBM();
            bm.AddJob("TravailASupprimer", @"C:\Source", @"C:\Cible", BackupType.Complete);
            int id = bm.GetAllJobs()[0].Id;

            bool resultat = bm.DeleteJob(id);

            Assert.IsTrue(resultat, "La suppression aurait dû retourner vrai.");
            Assert.AreEqual(0, bm.GetAllJobs().Count, "La liste des travaux devrait être vide.");
        }

        [TestMethod]
        public void TestSingleton_InstanceUnique()
        {
            var instance1 = BackupManager.GetBM();
            var instance2 = BackupManager.GetBM();

            Assert.AreSame(instance1, instance2, "Les deux variables doivent pointer vers la même instance (Singleton).");
        }
    }
}
</file>

<file path="EasyTest/BackupStrategyTests.cs">
using EasySave.Backup;
using System.Diagnostics;

namespace EasyTest
{
    [TestClass]
    public class BackupStrategyTests
    {
        private string _dossierSource = null!;
        private string _dossierCible = null!;
        private const string NomFichierTest = "fichier_test.txt";
        private const string NomFichierCrypto = "secret.txt";

        [TestInitialize]
        public void Setup()
        {
            _dossierSource = Path.Combine(Path.GetTempPath(), "EasySave_Source_Test");
            _dossierCible = Path.Combine(Path.GetTempPath(), "EasySave_Cible_Test");

            if (Directory.Exists(_dossierSource)) Directory.Delete(_dossierSource, true);
            if (Directory.Exists(_dossierCible)) Directory.Delete(_dossierCible, true);

            Directory.CreateDirectory(_dossierSource);

            var bm = BackupManager.GetBM();
            foreach (var job in bm.GetAllJobs()) bm.DeleteJob(job.Id);
        }

        [TestCleanup]
        public void Cleanup()
        {
            if (Directory.Exists(_dossierSource)) Directory.Delete(_dossierSource, true);
            if (Directory.Exists(_dossierCible)) Directory.Delete(_dossierCible, true);
        }

        [TestMethod]
        public void TestSauvegardeComplete_CopieFichiers()
        {
            File.WriteAllText(Path.Combine(_dossierSource, NomFichierTest), "Contenu de test");
            var bm = BackupManager.GetBM();
            bm.AddJob("TestComplet", _dossierSource, _dossierCible, BackupType.Complete);
            int id = bm.GetAllJobs()[0].Id;

            bm.ExecuteJob(id);

            string fichierCible = Path.Combine(_dossierCible, NomFichierTest);
            Assert.IsTrue(File.Exists(fichierCible), "Le fichier aurait dû être copié dans le dossier cible.");
            Assert.AreEqual("Contenu de test", File.ReadAllText(fichierCible));
        }

        [TestMethod]
        public void TestSauvegardeDifferentielle_FichierModifie()
        {
            string fichierSource = Path.Combine(_dossierSource, NomFichierTest);
            File.WriteAllText(fichierSource, "Version 1");

            var bm = BackupManager.GetBM();
            bm.AddJob("TestDiff", _dossierSource, _dossierCible, BackupType.Differential);
            int id = bm.GetAllJobs()[0].Id;

            bm.ExecuteJob(id);
            string fichierCible = Path.Combine(_dossierCible, NomFichierTest);
            DateTime datePremiereCopie = File.GetLastWriteTime(fichierCible);

            Thread.Sleep(1000);
            File.WriteAllText(fichierSource, "Version 2 - Modifié");

            bm.ExecuteJob(id);
            DateTime dateDeuxiemeCopie = File.GetLastWriteTime(fichierCible);

            Assert.AreNotEqual(datePremiereCopie, dateDeuxiemeCopie, "Le fichier cible aurait dû être mis à jour.");
            Assert.AreEqual("Version 2 - Modifié", File.ReadAllText(fichierCible));
        }

        [TestMethod]
        public void TestLogicielMetier_Blocage()
        {
            Process p = Process.Start("calc.exe");
            try
            {
                Thread.Sleep(2000);

                var bm = BackupManager.GetBM();
                bm.AddJob("TestBlocage", _dossierSource, _dossierCible, BackupType.Complete);
                int id = bm.GetAllJobs()[0].Id;

                bool succes = bm.ExecuteJob(id);

                Assert.IsFalse(succes, "Le job aurait dû échouer (retourner false) car la Calculatrice est ouverte.");
            }
            finally
            {
                if (p != null && !p.HasExited) p.Kill();
            }
        }

        [TestMethod]
        public void TestCryptoSoft_Integration()
        {
            string cheminFichierSource = Path.Combine(_dossierSource, NomFichierCrypto);
            string contenuClair = "Ceci est un secret";
            File.WriteAllText(cheminFichierSource, contenuClair);

            var bm = BackupManager.GetBM();
            bm.AddJob("TestCrypto", _dossierSource, _dossierCible, BackupType.Complete);
            int id = bm.GetAllJobs()[0].Id;

            bm.ExecuteJob(id);

            string cheminFichierCible = Path.Combine(_dossierCible, NomFichierCrypto);
            Assert.IsTrue(File.Exists(cheminFichierCible), "Le fichier crypté doit exister.");

            string contenuCible = File.ReadAllText(cheminFichierCible);

            Assert.AreNotEqual(contenuClair, contenuCible, "Le contenu du fichier cible devrait être crypté (différent de la source).");
        }
    }
}
</file>

<file path="EasyTest/EasyTest.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <LangVersion>latest</LangVersion>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="18.0.1" />
    <PackageReference Include="MSTest.TestAdapter" Version="3.1.1" />
    <PackageReference Include="MSTest.TestFramework" Version="3.1.1" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\EasySave\EasySave.csproj" />
  </ItemGroup>

  <ItemGroup>
    <Using Include="Microsoft.VisualStudio.TestTools.UnitTesting" />
  </ItemGroup>

</Project>
</file>

<file path="EasyTest/LogTests.cs">
using EasyLog.Data;
using EasyLog.Logging;

namespace EasyTest
{
    [TestClass]
    public class LogTests
    {
        private string _dossierLogs = null!;

        [TestInitialize]
        public void Setup()
        {
            _dossierLogs = Path.Combine(Path.GetTempPath(), "EasySave_Logs_Test");
            if (Directory.Exists(_dossierLogs)) Directory.Delete(_dossierLogs, true);
            Directory.CreateDirectory(_dossierLogs);
        }

        [TestMethod]
        public void TestJsonLogger_CreationFichier()
        {
            var logger = LoggerFactory.CreateLogger("json", _dossierLogs);
            var entree = new LogEntry
            {
                Name = "SauvegardeTestJSON",
                SourceFile = @"C:\Source\doc.txt",
                TargetFile = @"C:\Cible\doc.txt",
                FileSize = 1024,
                ElapsedTime = 50,
                EncryptionTime = 15 
            };

            logger.Log(entree);

            string fichierLog = Path.Combine(_dossierLogs, $"{DateTime.Now:yyyy-MM-dd}.json");
            Assert.IsTrue(File.Exists(fichierLog), "Le fichier de log JSON aurait dû être créé.");

            string contenu = File.ReadAllText(fichierLog);
            Assert.IsTrue(contenu.Contains("SauvegardeTestJSON"), "Le log doit contenir le nom de la sauvegarde.");
            Assert.IsTrue(contenu.Contains("\"EncryptionTime\": 15"), "Le log doit contenir le temps de cryptage.");
        }

        [TestMethod]
        public void TestXmlLogger_CreationFichier()
        {
            var logger = LoggerFactory.CreateLogger("xml", _dossierLogs);
            var entree = new LogEntry
            {
                Name = "SauvegardeTestXML",
                SourceFile = "Source",
                TargetFile = "Target",
                FileSize = 500,
                ElapsedTime = 20
            };

            logger.Log(entree);

            string fichierLog = Path.Combine(_dossierLogs, $"{DateTime.Now:yyyy-MM-dd}.xml");
            Assert.IsTrue(File.Exists(fichierLog), "Le fichier de log XML aurait dû être créé.");

            string contenu = File.ReadAllText(fichierLog);
            Assert.IsTrue(contenu.Contains("<Name>SauvegardeTestXML</Name>"), "Le log doit contenir les balises XML correctes.");
        }
    }
}
</file>

<file path="EasyTest/MSTestSettings.cs">
/// <summary>
/// Configures the parallel execution policy for the test assembly.
/// </summary>
/// <remarks>
/// This attribute enables parallel execution of tests at the method level. 
/// It allows distinct test methods to run concurrently, thereby reducing the overall time required to execute the test suite.
/// </remarks>
[assembly: Parallelize(Scope = ExecutionScope.MethodLevel)]
</file>

<file path="EasyTest/Test1.cs">
namespace EasyTest
{
    /// <summary>
    /// Represents a placeholder test class used to verify the proper configuration of the unit testing framework.
    /// </summary>
    [TestClass]
    public sealed class Test1
    {
        /// <summary>
        /// Executes a basic test method to ensure that the test runner is operating correctly.
        /// </summary>
        [TestMethod]
        public void TestMethod1()
        {
        }
    }
}
</file>

<file path="EasyLog/Logging/JsonLogger.cs">
using System.Text.Json;
using EasyLog.Data;

namespace EasyLog.Logging
{
    /// <summary>
    /// Logger implementation that outputs logs in JSON format.
    /// </summary>
    /// <remarks>
    /// This logger serializes log entries into a JSON array. It handles reading existing logs
    /// to append new entries while maintaining a valid JSON structure.
    /// </remarks>
    /// <param name="path">The directory path where log files will be created.</param>
    public class JsonLogger(string path) : AbstractLogger(path)
    {
        private readonly object _lock = new();

        /// <summary>
        /// Gets the file extension for JSON log files.
        /// </summary>
        /// <returns>The string "json".</returns>
        public override string GetExtension() => "json";

        /// <summary>
        /// Writes a log entry to the JSON log file.
        /// </summary>
        /// <remarks>
        /// This method is thread-safe for writing. It reads the entire existing log file,
        /// deserializes it into a list, adds the new entry, and rewrites the file with indentation.
        /// </remarks>
        /// <param name="message">The log entry object to be serialized and written.</param>
        public override void Log(LogEntry message)
        {
            List<LogEntry> logs = new List<LogEntry>();
            if (File.Exists(LogFile))
            {
                string existingContent = File.ReadAllText(LogFile);
                if (!string.IsNullOrWhiteSpace(existingContent))
                {
                    logs = JsonSerializer.Deserialize<List<LogEntry>>(existingContent) ?? new List<LogEntry>();
                }
            }
            logs.Add(message);
            lock (_lock)
            {
                File.WriteAllText(LogFile, JsonSerializer.Serialize(logs, new JsonSerializerOptions { WriteIndented = true }));
            }
        }
    }
}
</file>

<file path="EasyLog/Logging/XmlLogger.cs">
using EasyLog.Data;
using System.Xml.Serialization;

namespace EasyLog.Logging
{
    /// <summary>
    /// Logger implementation that outputs logs in XML format.
    /// </summary>
    /// <remarks>
    /// This logger serializes log entries into an XML structure. It handles reading existing logs,
    /// deserializing them to append the new entry, and serializing the updated list back to the file.
    /// </remarks>
    /// <param name="path">The directory path where log files will be created.</param>
    public class XmlLogger(string path) : AbstractLogger(path)
    {
        private readonly object _lock = new();

        /// <summary>
        /// Gets the file extension for XML log files.
        /// </summary>
        /// <returns>The string "xml".</returns>
        public override string GetExtension() => "xml";

        /// <summary>
        /// Writes a log entry to the XML log file.
        /// </summary>
        /// <remarks>
        /// This method is thread-safe for writing. It reads the existing XML content,
        /// deserializes it into a list of LogEntries, adds the new message, and overwrites the file
        /// with the updated serialized XML data.
        /// </remarks>
        /// <param name="message">The log entry object to be serialized and written.</param>
        public override void Log(LogEntry message)
        {
            List<LogEntry> logs = new List<LogEntry>();
            if (File.Exists(LogFile))
            {
                string existingContent = File.ReadAllText(LogFile);
                if (!string.IsNullOrWhiteSpace(existingContent))
                {
                    var serializer = new XmlSerializer(typeof(List<LogEntry>));
                    using var reader = new StringReader(existingContent);
                    logs = serializer.Deserialize(reader) as List<LogEntry> ?? new();
                }
            }
            logs.Add(message);
            lock (_lock)
            {
                var serializer = new XmlSerializer(typeof(List<LogEntry>));
                using var writer = new StringWriter();
                serializer.Serialize(writer, logs);
                File.WriteAllText(LogFile, writer.ToString());
            }
        }
    }
}
</file>

<file path="EasySave/EasySave.csproj">
<Project Sdk="Microsoft.NET.Sdk">
	
	<PropertyGroup>
		<TargetFramework>net8.0</TargetFramework>
		<ImplicitUsings>enable</ImplicitUsings>
		<Nullable>enable</Nullable>
		<PublishSingleFile>true</PublishSingleFile>
		<SelfContained>true</SelfContained>
		<IncludeAllContentForSelfExtract>true</IncludeAllContentForSelfExtract>
		<PublishReadyToRun>true</PublishReadyToRun>
	</PropertyGroup>
	
	<ItemGroup>
		<PackageReference Include="Newtonsoft.Json" Version="9.0.1" />
	</ItemGroup>
	
	<ItemGroup>
		<EmbeddedResource Include="default.json" />
		<EmbeddedResource Include="i18n/*.json" />
	</ItemGroup>
	
	<ItemGroup>
		<ProjectReference Include="..\EasyLog\EasyLog.csproj" />
	</ItemGroup>
	
</Project>
</file>

<file path="EasySave/Extensions/BackupTypeExt.cs">
using EasySave.Backup;
using EasySave.View.Localization;

namespace EasySave.Extensions
{
    /// <summary>
    /// Provides extension methods for the BackupType enumeration to facilitate localization and display.
    /// </summary>
    public static class BackupTypeExt
    {

        /// <summary>
        /// Retrieves the localized string representation of the specified backup type.
        /// </summary>
        /// <param name="type">The backup type to translate. Can be Complete, Differential, or Incremental.</param>
        /// <returns>A localized string corresponding to the backup type found in the I18n resources. Returns "not_translated" for unsupported types.</returns>
        public static string GetTranslation(this BackupType type)
        {
            return I18n.Instance.GetString(type switch
            {
                BackupType.Complete     => "type_complete",
                BackupType.Differential => "type_differential",
                BackupType.Incremental  => "not_translated",
                _                       => "not_translated",
            });
        }
    }
}
</file>

<file path="EasySave/Extensions/StateExt.cs">
using EasySave.Backup;
using EasySave.View.Localization;

namespace EasySave.Extensions
{
    /// <summary>
    /// Provides extension methods for the State enumeration to facilitate localization and display.
    /// </summary>
    public static class StateExt
    {

        /// <summary>
        /// Retrieves the localized string representation of the specified backup state.
        /// </summary>
        /// <param name="state">The backup state to translate. Can be Inactive, Active, Completed, or Error.</param>
        /// <returns>A localized string corresponding to the state found in the I18n resources. Returns the translation for "state_inactive" if the state is not recognized.</returns>
        public static string GetTranslation(this State state)
        {
            return I18n.Instance.GetString(state switch
            {
                State.Inactive  => "state_inactive",
                State.Active    => "state_active",
                State.Completed => "state_completed",
                State.Error     => "state_error",
                _               => "state_inactive"
            });
        }

    }
}
</file>

<file path="EasySave/Program.cs">
namespace EasySave
{
    /// <summary>
    /// Main entry point of the EasySave application.
    /// </summary>
    class Program
    {
        /// <summary>
        /// Main method of the project executed at the launch of the application.
        /// </summary>
        /// <param name="args">Array of arguments passed on the command line at the start of the application.</param>
        static void Main(string[] args)
        {
        }
    }
}
</file>

<file path="EasySave/Utils/PathUtils.cs">
using System.Net;

namespace EasySave.Utils
{
    /// <summary>
    /// Provides utility methods for handling file paths.
    /// </summary>
    public static class PathUtils
    {
        /// <summary>
        /// Converts a local file path to a UNC (Universal Naming Convention) path.
        /// </summary>
        /// <remarks>
        /// This method converts a local path like "C:\Folder\File.txt" to a network share path 
        /// like "\\Hostname\C$\Folder\File.txt". If the path is already in UNC format or cannot be converted, 
        /// the original path is returned.
        /// </remarks>
        /// <param name="path">The local file path to convert.</param>
        /// <returns>The path in UNC format, or the original path if conversion is not applicable.</returns>
        public static string ToUnc(string? path)
        {
            if (string.IsNullOrEmpty(path)) return string.Empty;

            // If it is already a UNC path, return it as is
            if (path.StartsWith(@"\\")) return path;

            try
            {
                // Get the root of the path (e.g., "C:\")
                string? root = Path.GetPathRoot(path);

                // If no root is found or it's a relative path, return original
                if (string.IsNullOrEmpty(root)) return path;

                // Remove the trailing separator to get the drive (e.g., "C:")
                string drive = root.TrimEnd(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);

                // Replace the colon with a dollar sign for administrative share (e.g., "C$")
                if (drive.EndsWith(":"))
                {
                    drive = drive[..^1] + "$";
                }
                else
                {
                    // If it doesn't look like a drive letter, return original
                    return path;
                }

                // Get the rest of the path without the root
                string relativePath = path[root.Length..];

                // Get the machine's host name
                string hostName = Dns.GetHostName();

                // Combine to form the UNC path: \\Hostname\Drive$\Path
                return Path.Combine($"\\\\{hostName}\\{drive}", relativePath);
            }
            catch
            {
                // In case of any parsing error, fallback to the original path
                return path;
            }
        }
    }
}
</file>

<file path="EasySave/View/Localization/I18n.cs">
using EasySave.Utils;
using Newtonsoft.Json;
using System.ComponentModel;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;

namespace EasySave.View.Localization
{
	/// <summary>
	/// Provides internationalization (i18n) support by managing available languages and retrieving localized strings for
	/// the application.
	/// </summary>
	/// <remarks>This class implements a singleton pattern to ensure a single instance manages language resources
	/// throughout the application. It allows switching between supported languages at runtime and retrieving localized
	/// strings based on the current language. The class loads language resources embedded in the assembly and exposes
	/// methods to access translations and language metadata.</remarks>
	public partial class I18n : INotifyPropertyChanged
	{
		private readonly Dictionary<string, string> availableLanguages;

		private Dictionary<string, string> translations;

		private Dictionary<string, Dictionary<string, string>> properties;

		public event PropertyChangedEventHandler? PropertyChanged;

		protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
		{
			PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
		}

		public string this[string key] => GetString(key);

		public string Language { get; private set; } = string.Empty;

		private static I18n? _instance;

		/// <summary>
		/// Static singleton getter of I18n class.
		/// </summary>
		/// <returns>
		/// An instance of I18n class.
		/// </returns>
		public static I18n Instance
		{

			get
			{
				_instance ??= new I18n();
				return _instance;
			}

		}

		/// <summary>
		/// Initializes a new instance of the I18n class and loads available language resources from the executing assembly.
		/// </summary>
		/// <remarks>This constructor scans the assembly for embedded language resources and prepares the internal
		/// language mapping. The default language is set to English ("en_us") upon initialization. This constructor is
		/// intended for internal use and is not accessible outside the class.</remarks>
		private I18n() {
			availableLanguages = [];
			translations       = [];
			properties         = [];
			var langs = Assembly.GetExecutingAssembly()
				.GetManifestResourceNames()
				.Where(e => e.Contains(".i18n."));
			foreach (var lang in langs)
			{
				Match match = LocaleRegex().Match(lang);
				if (match.Success)
				{
					string localeName = match.Groups[1].Value.Split('.')[0];  // 1 = premier groupe de capture
					availableLanguages[localeName] = lang;
				}
			}
			SetLanguage("en_us");
		}

		/// <summary>
		/// Sets the current language for translations using the specified language name.
		/// </summary>
		/// <remarks>Calling this method updates the active translations to those associated with the specified
		/// language. Any subsequent translation lookups will use the newly set language.</remarks>
		/// <param name="languageName">The name of the language to set as the current language. Must correspond to an available language.</param>
		/// <exception cref="ArgumentException">Thrown if the specified language name does not exist in the available languages.</exception>
		public void SetLanguage(string languageName)
		{
			if (!availableLanguages.ContainsKey(languageName))
				throw new ArgumentException("This language does not exists!");
			Language = languageName;
			string jsonContent = ResourceManager.ReadResourceFile(availableLanguages[languageName]);
			translations = JsonConvert.DeserializeObject<Dictionary<string, string>>(jsonContent) ?? new Dictionary<string, string>();

			// Notifier que toute l'instance a changé
			OnPropertyChanged(string.Empty); // Notifie TOUTES les propriétés
		}

		/// <summary>
		/// Retrieves the localized string associated with the specified key.
		/// </summary>
		/// <param name="key">The key that identifies the localized string to retrieve. Cannot be null.</param>
		/// <returns>The localized string corresponding to the specified key if found; otherwise, the key itself.</returns>
		public string GetString(string key)
		{
			if (translations.TryGetValue(key, out string? value))
				return value;
			return key;
		}

		/// <summary>
		/// Loads the language property dictionaries for all available languages.
		/// </summary>
		/// <remarks>Use this method to retrieve all language-specific properties that are marked with a leading '@'
		/// in their keys. The returned structure allows access to these properties by language.</remarks>
		/// <returns>A dictionary where each key is a language identifier and each value is a dictionary containing the language's
		/// properties. Only properties with keys that start with '@' are included.</returns>
		public Dictionary<string, Dictionary<string, string>> LoadLanguagesProperties()
		{
			if (properties.Count == 0)
			{
				foreach (var pair in availableLanguages)
				{
					properties[pair.Key] = JsonConvert
						.DeserializeObject<Dictionary<string, string>>(ResourceManager.ReadResourceFile(pair.Value))
						.Where(p => p.Key.StartsWith("@"))
						.ToDictionary<string, string>();
				}
			}
			return properties;
		}

		[GeneratedRegex(@".*(\w{2}_\w{2}\.json?)")]
        private static partial Regex LocaleRegex();
    }
}
</file>

<file path="EasyTest/TestConfigManager.cs">
using EasySave.Backup;
using System.Text.Json;
using System.Text.Json.Serialization;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace EasyTest
{
    /// <summary>
    /// Test class responsible for verifying configuration management and object serialization.
    /// </summary>
    [TestClass]
    public sealed class TestConfigManager
    {
        /// <summary>
        /// Verifies the JSON serialization and deserialization of a <see cref="BackupJob"/> object.
        /// </summary>
        /// <remarks>
        /// This test creates a sample backup job, serializes it to a formatted JSON string, 
        /// compares the JSON output against an expected string literal, and finally deserializes 
        /// it back to ensure the resulting object is equal to the original.
        /// </remarks>
        [TestMethod]
        public void TestBackupJobSerialization()
        {
            var job = new BackupJob(1, "Test", @"C:\xampp\htdocs\_source", @"C:\xampp\htdocs\_target", BackupType.Complete);

            string json = JsonSerializer.Serialize(job, new JsonSerializerOptions
            {
                WriteIndented = true,
                Converters = { new JsonStringEnumConverter() },
                IncludeFields = true
            });

            Assert.AreEqual(json,
"""
{
  "Id": 1,
  "Name": "Test",
  "SourceDirectory": "C:\\xampp\\htdocs\\_source",
  "TargetDirectory": "C:\\xampp\\htdocs\\_target",
  "Type": "Complete",
  "LastExecution": "0001-01-01T00:00:00",
  "State": "Inactive"
}
""");

            var job2 = JsonSerializer.Deserialize<BackupJob>(json);

            Assert.AreEqual(job, job2);
        }
    }
}
</file>

<file path="EasyConsole/View/ConsoleView.cs">
using EasySave.Backup;
using EasySave.Extensions;
using EasyConsole.View.Command;
using EasySave.View.Localization;

namespace EasyConsole.View
{
	/// <summary>
	/// Console View - Handles user interface (View in MVVM)
	/// <para>
	/// The ConsoleView class act like the View in your software architecture.
	/// It is responsible of menu displaying and get user input.
	/// </para>
	/// </summary>
	public class ConsoleView
	{
        /// <summary>
        /// Initialization of the new instance for the console view.
		/// Load the unique instance needed for the functioning of the application system.
        /// </summary>
        public ConsoleView()
		{
			// Initialization of Singleton instances
			_ = BackupManager.GetBM();
			_ = BackupManager.GetLogger();
			_ = I18n.Instance;
		}

        /// <summary>
        /// Start the application system in console mode.
        /// </summary>
        /// <param name="args">Arguments input from the command line when the application is launched.</param>
        public static void Run(string[] args)
		{
			// Check for command line arguments
			if (args.Length > 0)
			{
                ProcessCommandLine(args);
				return;
			}

			var context = CommandContext.Instance;

			// Interactive menu mode
			while (true)
			{
				BackupManager.GetBM().TransmitSignal(Signal.Continue);
				context.DisplayCommands();
                int choice;
                try
				{
					choice = ConsoleExt.ReadDec();
				} catch(FormatException)
				{
					Console.WriteLine(I18n.Instance.GetString("invalid_choice"));
					_ = Console.ReadLine();
					continue;
				}
				if (!context.ExecuteCommand(choice))
					Console.WriteLine(I18n.Instance.GetString("invalid_choice"));
				Console.WriteLine($"\n{I18n.Instance.GetString("press_enter")}");
				_ = Console.ReadLine();

				if (BackupManager.GetBM().LatestSignal == Signal.None)
					throw new InvalidOperationException("Oops! This should not happen!");

				if (BackupManager.GetBM().LatestSignal == Signal.Exit)
				{
					break;
				}
			}
		}

		/// <summary>
		/// Parses and processes command-line arguments to execute one or more backup jobs based on the specified input
		/// format.
		/// </summary>
		/// <remarks>The method supports three input formats for specifying backup jobs: a single integer for one job,
		/// a hyphen-separated range for multiple jobs, or a semicolon-separated list for specific jobs. If the input does not
		/// match any of these formats or is invalid, no jobs are executed. Any exceptions encountered during processing are
		/// caught and an error message is displayed.</remarks>
		/// <param name="args">An array of command-line arguments.
		/// <item><description>"1-3" : range of ID </description></item>
		/// <item><description>"1;3" : list of ID</description></item>
		/// <item><description>"1" : unique ID</description></item>
		/// </param>
		public static void ProcessCommandLine(string[] args)
		{
			try
			{
				// Parse command line: EasySave.exe 1-3 or EasySave.exe 1;3
				string argument = args[0];

				if (argument.Contains('-'))
				{
					// Range: 1-3
					var parts = argument.Split('-');
					if (parts.Length == 2 && int.TryParse(parts[0], out int start) && int.TryParse(parts[1], out int end))
					{
						Console.WriteLine($"Executing backup jobs {start} to {end}...");
						BackupManager.GetBM().ExecuteJobRange(start, end, DisplayProgress);
						Console.WriteLine("Execution completed!");
					}
				}
				else if (argument.Contains(';'))
				{
					// List: 1;3;5
					var parts = argument.Split(';');
					var ids = parts.Select(p => int.TryParse(p, out int id) ? id : -1).Where(id => id != -1).ToArray();
					
					if (ids.Length > 0)
					{
						Console.WriteLine($"Executing backup jobs: {string.Join(", ", ids)}...");
						BackupManager.GetBM().ExecuteJobList(ids, DisplayProgress);
						Console.WriteLine("Execution completed!");
					}
				}
				else if (int.TryParse(argument, out int singleId))
				{
					// Single job
					Console.WriteLine($"Executing backup job {singleId}...");
					BackupManager.GetBM().ExecuteJob(singleId, DisplayProgress);
					Console.WriteLine("Execution completed!");
				}
			}
			catch (Exception e)
			{
				Console.WriteLine("{0}: {1}", I18n.Instance.GetString("error"), e.Message);
			}
		}

		public static void DisplayProgress(ProgressState state)
		{
            if (!string.IsNullOrEmpty(state.Message))
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine($"\n >> {state.Message}");
                Console.ResetColor();
                if (state.State == State.Error) return;
            }

            Console.WriteLine($"\n{I18n.Instance.GetString("progress_active")}");
			Console.WriteLine(string.Format(I18n.Instance.GetString("progress_files"), 
				state.TotalFiles - state.FilesRemaining, state.TotalFiles));
			Console.WriteLine(string.Format(I18n.Instance.GetString("progress_size"), 
				state.TotalSize - state.SizeRemaining, state.TotalSize));
			Console.WriteLine(string.Format(I18n.Instance.GetString("progress_percentage"), 
				state.ProgressPercentage));
			
			if (!string.IsNullOrEmpty(state.CurrentSourceFile))
			{
				Console.WriteLine(string.Format(I18n.Instance.GetString("progress_current"), 
					Path.GetFileName(state.CurrentSourceFile)));
			}
		}
		
	}
}
</file>

<file path="EasyGUI/App.axaml">
<Application xmlns="https://github.com/avaloniaui"
			 xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
			 x:Class="EasyGUI.App"  xmlns:local="using:EasyGUI"
			 RequestedThemeVariant="Default">

	<Application.DataTemplates>
		<local:ViewLocator/>
	</Application.DataTemplates>

	<Application.Resources>
		<!-- Ressources pour le thème clair -->
		<ResourceDictionary>
			<ResourceDictionary.ThemeDictionaries>
				<ResourceDictionary x:Key="Light">
					<SolidColorBrush x:Key="AppBackgroundBrush" Color="White"/>
					<SolidColorBrush x:Key="CardBackgroundBrush" Color="#EBEBEB"/>
				</ResourceDictionary>
				<ResourceDictionary x:Key="Dark">
					<SolidColorBrush x:Key="AppBackgroundBrush" Color="#0D0D0D"/>
					<SolidColorBrush x:Key="CardBackgroundBrush" Color="#1A1A1A"/>
				</ResourceDictionary>
			</ResourceDictionary.ThemeDictionaries>
		</ResourceDictionary>
	</Application.Resources>

	<Application.Styles>
		<FluentTheme />

		<!-- Sidebar avec la même couleur que les cartes -->
		<Style Selector="Border.Sidebar">
			<Setter Property="Background" Value="{DynamicResource CardBackgroundBrush}"/>
			<Setter Property="BoxShadow" Value="4 0 15 0 #20000000"/>
		</Style>

		<Style Selector="Button.NavButton">
			<Setter Property="Background" Value="Transparent"/>
			<Setter Property="FontSize" Value="15"/>
			<Setter Property="Padding" Value="15, 12"/>
			<Setter Property="HorizontalAlignment" Value="Stretch"/>
			<Setter Property="HorizontalContentAlignment" Value="Left"/>
			<Setter Property="CornerRadius" Value="8"/>
			<Setter Property="Margin" Value="10,2"/>
			<Setter Property="BorderThickness" Value="0"/>
			<Setter Property="Transitions">
				<Transitions>
					<BrushTransition Property="Background" Duration="0:0:0.2"/>
				</Transitions>
			</Setter>
		</Style>
		<Style Selector="Button.NavButton:pointerover /template/ ContentPresenter">
			<Setter Property="Background" Value="{DynamicResource ButtonBackgroundPointerOver}"/>
		</Style>

		<Style Selector="Button.Primary">
			<Setter Property="Background" Value="#F6E05E"/>
			<Setter Property="Foreground" Value="#2D3748"/>
			<Setter Property="FontWeight" Value="SemiBold"/>
			<Setter Property="Padding" Value="20,10"/>
			<Setter Property="CornerRadius" Value="6"/>
			<Setter Property="Cursor" Value="Hand"/>
		</Style>
		<Style Selector="Button.Primary:pointerover /template/ ContentPresenter">
			<Setter Property="Background" Value="#ECC94B"/>
		</Style>

		<!-- Cartes : utilisent les ressources dynamiques du thème -->
		<Style Selector="Border.Card">
			<Setter Property="Background" Value="{DynamicResource CardBackgroundBrush}"/>
			<Setter Property="CornerRadius" Value="12"/>
			<Setter Property="BoxShadow" Value="0 4 10 0 #15000000"/>
			<Setter Property="Padding" Value="30"/>
			<Setter Property="Margin" Value="20"/>
		</Style>

		<Style Selector="TextBox">
			<Setter Property="CornerRadius" Value="4"/>
			<Setter Property="Padding" Value="10"/>
		</Style>
		<Style Selector="TextBox:focus /template/ Border#PART_BorderElement">
			<Setter Property="BorderBrush" Value="#F6E05E"/>
		</Style>

	</Application.Styles>
</Application>
</file>

<file path="EasyLog/Data/LogEntry.cs">
using EasyLog.Logging;

namespace EasyLog.Data
{
    //public record LogEntry(int Timestamp, string Name, string Source, string Target, long Size, long ElapsedTime) {}

    /// <summary>
    /// Represents a single log entry containing details about an event or a backup operation.
    /// </summary>
    /// <remarks>
    /// This class is designed to handle different types of logs: standard messages, errors with stack traces,
    /// and specific backup operation details (source, target, size, duration).
    /// </remarks>
    public class LogEntry
    {
        /// <summary>
        /// Gets the timestamp of when the log entry was created.
        /// </summary>
        /// <remarks>Initialized automatically to the current system time.</remarks>
        public string Timestamp { get; } = DateTime.Now.ToString();

        /// <summary>
        /// Gets or sets the severity level of the log entry.
        /// </summary>
        public Level Level { get; set; } = Level.Info;

        /// <summary>
        /// Gets or sets the main text message of the log entry.
        /// </summary>
        public string? Message { get; set; }

        /// <summary>
        /// Gets or sets the stack trace associated with an error, if applicable.
        /// </summary>
        public string? Stacktrace { get; set; }

        /// <summary>
        /// Gets or sets the name of the backup job associated with this entry.
        /// </summary>
        public string? Name { get; set; }

        /// <summary>
        /// Gets or sets the full path of the source file.
        /// </summary>
        public string? SourceFile { get; set; }

        /// <summary>
        /// Gets or sets the full path of the target (destination) file.
        /// </summary>
        public string? TargetFile { get; set; }

        /// <summary>
        /// Gets or sets the size of the file in bytes.
        /// </summary>
        public long? FileSize { get; set; }

        /// <summary>
        /// Gets or sets the time elapsed during the file transfer operation (in milliseconds).
        /// </summary>
        public long? ElapsedTime { get; set; }

        /// <summary>
        /// Gets or sets the time taken to encrypt the file (in milliseconds).
        /// </summary>
        /// <remarks>
        /// 0 means no encryption was performed.
        /// A negative value (e.g., -1) indicates an error during the encryption process.
        /// </remarks>
        public int EncryptionTime { get; set; } = 0;

        /// <summary>
        /// Formats the backup-specific properties into a structured string.
        /// </summary>
        /// <returns>A string containing the name, source, destination, size, elapsed time, and encryption time.</returns>
        public string ToBackupString()
        {
            return $"Backup name: {Name}, Source: {SourceFile}, Destination: {TargetFile}, Size: {FileSize}, ElapsedTime: {ElapsedTime}ms, EncryptionTime: {EncryptionTime}ms";
        }

        /// <summary>
        /// Returns a string representation of the current log entry.
        /// </summary>
        /// <remarks>
        /// The format changes based on the available data:
        /// <list type="bullet">
        /// <item>If backup data is present, it returns the formatted backup string.</item>
        /// <item>If a message and stacktrace are present, it formats it as an error log.</item>
        /// <item>Otherwise, it returns the simple message.</item>
        /// </list>
        /// </remarks>
        /// <returns>The formatted log string prefixed with the timestamp and level.</returns>
        public override string ToString()
        {
            string body = string.Empty;
            if (Name != null && SourceFile != null && TargetFile != null && FileSize != null && ElapsedTime != null)
                body = ToBackupString();
            else if (Message != null && Stacktrace != null)
            {
                Level = Level.Error;
                body = Message + "\n";
                body += $"[{Timestamp}] {Level}: Stacktrace: {Stacktrace}";
            }
            else
                body = Message ?? string.Empty;
            return $"[{Timestamp}] {Level}: {body}";
        }

    }
}
</file>

<file path="EasyLog/Logging/LoggerFactory.cs">
namespace EasyLog.Logging
{
    /// <summary>
    /// Factory class responsible for creating logger instances.
    /// Implements the Factory Method pattern to decouple logger instantiation from usage.
    /// </summary>
    public static class LoggerFactory
    {

        private static readonly Dictionary<string, Type> _loggers = new()
        {
            { "text", typeof(SimpleLogger) },
            { "json", typeof(JsonLogger)   },
            { "xml",  typeof(XmlLogger)    },
        };

        /// <summary>
        /// Creates and returns an instance of a logger based on the specified type.
        /// </summary>
        /// <param name="type">The type of logger to create (e.g., "text", "json", "xml").</param>
        /// <param name="path">The file path where the logger will write its output.</param>
        /// <returns>An instance implementing the <see cref="ILogger"/> interface.</returns>
        /// <exception cref="ArgumentException">Thrown when the specified logger type is not found in the registry.</exception>
        /// <exception cref="Exception">Thrown when the logger instance could not be initialized.</exception>
        public static ILogger CreateLogger(string type, string path)
        {
            Type loggerType = _loggers[type] ?? throw new ArgumentException("This logger type doesn't exists!");
            return (ILogger)(Activator.CreateInstance(loggerType, path) ?? throw new Exception("A logger couldn't have been initialized!"));
        }

    }
}
</file>

<file path="EasyLog/Program.cs">
using EasyLog.Data;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace EasyLog
{
    /// <summary>
    /// Represents the entry point for the EasyLog application.
    /// </summary>
    public class Program
    {
        /// <summary>
        /// Main entry point of the application.
        /// </summary>
        /// <param name="args">Command-line arguments passed to the application.</param>
        public static void Main(string[] args)
        {

        }
    }
}
</file>

<file path="EasySave/Backup/IBackupStrategy.cs">
namespace EasySave.Backup
{
	/// <summary>
	/// Strategy interface for backup implementations (Strategy Pattern)
	/// </summary>
	public interface IBackupStrategy
	{
		/// <summary>
		/// Executes the backup strategy
		/// </summary>
		void Execute(BackupJob job, string BusinessSoftware, Action<ProgressState> progressCallback);
	}
}
</file>

<file path="EasySave/Backup/ProgressState.cs">
namespace EasySave.Backup
{
    /// <summary>
    /// Represents the current state of a backup operation
    /// </summary>
    public class ProgressState
    {
        public string BackupName { get; set; }
        public DateTime Timestamp { get; set; }
        public State State { get; set; }
        public int TotalFiles { get; set; }
        public long TotalSize { get; set; }
        public int FilesRemaining { get; set; }
        public long SizeRemaining { get; set; }
        public string CurrentSourceFile { get; set; }
        public string CurrentTargetFile { get; set; }
        public double ProgressPercentage { get; set; }

        public string Message { get; set; }

        /// <summary>
        /// Initializes a new instance of the ProgressState class with default values.
        /// </summary>
        /// <remarks>The default constructor sets all string properties to empty strings, the timestamp to
        /// the current date and time, and the state to Inactive. This ensures the object starts in a consistent,
        /// inactive state before any progress tracking begins.</remarks>
        public ProgressState()
        {
            BackupName        = string.Empty;
            Timestamp         = DateTime.Now;
            State             = State.Inactive;
            CurrentSourceFile = string.Empty;
            CurrentTargetFile = string.Empty;
            Message = string.Empty;
        }
    }
}
</file>

<file path="EasySave/i18n/en_us.json">
{
	"@language_name": "English",
	"app_title": "Backup Manager",
	"menu_dashboard": "Dashboard",
	"menu_create": "New Job",
	"menu_execute": "Execute Job",
	"menu_execute_all": "Execute All",
	"menu_list": "Job List",
	"menu_delete": "Delete Job",
	"menu_settings": "Settings",
	"menu_language": "Language",
	"menu_exit": "Exit",
	"menu_actions_title": "ACTIONS",

	"dashboard_welcome": "Welcome to EasySave",
	"dashboard_subtitle": "Your reliable backup solution",
	"dashboard_status": "Status",
	"dashboard_jobs_count": "backup jobs",

	"theme_dark": "Dark theme",
	"theme_light": "Light theme",

	"create_title": "Create a New Backup Job",
	"create_name": "Job Name:",
	"create_source": "Source Path:",
	"create_target": "Target Path:",
	"create_type": "Backup Type:",
	"create_button": "Create",
	"create_success": "Backup job created successfully!",
	"create_failure": "Failed to create backup job. Maximum limit reached or invalid data.",

	"execute_title": "Execute a Backup Job",
	"execute_subtitle": "Select a job to start backup",
	"execute_placeholder": "Choose a backup job...",
	"execute_processing": "Processing...",
	"execute_select": "Select a job to execute:",
	"execute_button": "Execute",
	"execute_id": "Enter backup job ID to execute",
	"execute_success": "Backup job completed successfully!",
	"execute_failure": "Failed to execute backup job",
	"execute_all_title": "Execute All Backup Jobs",
	"execute_all_subtitle": "All backups will be executed sequentially",
	"execute_waiting": "Waiting...",
	"execute_completed": "Completed!",
	"execute_all_completed": "All jobs completed successfully!",
	"execute_all_start": "Executing all backup jobs...",
	"execute_no_jobs": "No backup jobs available. Create one first!",

	"list_title": "All Backup Jobs",
	"list_empty": "No backup jobs found.",
	"list_id": "ID:",
	"list_name": "Name:",
	"list_source": "Source:",
	"list_target": "Target:",
	"list_type": "Type:",
	"list_state": "State",
	"list_last_exec": "Last Execution",

	"delete_title": "Delete a Backup Job",
	"delete_select": "Select a job to delete:",
	"delete_button": "Delete",
	"delete_warning": "⚠️ Warning: This action is permanent and cannot be undone!",
	"delete_no_jobs": "No backup jobs available.",
	"delete_id": "Enter backup job ID to delete",
	"delete_success": "Backup job deleted successfully!",
	"delete_failure": "Failed to delete backup job.",

	"settings_title": "Settings",
	"settings_lang": "Language:",
	"settings_window_mode": "Window Mode:",
	"settings_window_windowed": "Windowed",
	"settings_window_maximized": "Fullscreen (Maximized)",
	"settings_window_fullscreen": "Fullscreen (Borderless)",
	"settings_applied": "Settings applied successfully!",
	"language_title": "Change Language",
	"language_select": "Select language:",
	"language_apply": "Apply",
	"language_changed": "✓ Language changed to English!",

	"btn_save": "Save",
	"btn_cancel": "Cancel",
	"btn_apply": "Apply",
	"btn_delete": "Delete",
	"btn_start": "Start Backup",
	"btn_start_all": "Start All Backups",
	"button_cancel": "Cancel",
	"button_back": "Back to Menu",

	"progress_active": "Status: Active",
	"progress_files": "Files: {0}/{1}",
	"progress_size": "Size: {0}/{1} bytes",
	"progress_current": "Current file: {0}",
	"progress_percentage": "Progress: {0:F2}%",

	"press_enter": "Press Enter to continue...",
	"invalid_choice": "Invalid choice. Please try again.",
	"error": "Error",
	"type_complete": "Complete",
	"type_differential": "Differential",
	"state_active": "Active",
	"state_inactive": "Inactive",
	"state_completed": "Completed",
	"state_error": "Error",
	"never": "Never"
}
</file>

<file path="EasySave/i18n/fr_fr.json">
{
	"@language_name": "Français",
	"app_title": "Gestionnaire de Sauvegardes",
	"menu_dashboard": "Tableau de Bord",
	"menu_create": "Nouveau Travail",
	"menu_execute": "Exécuter",
	"menu_execute_all": "Tout Exécuter",
	"menu_list": "Liste des Travaux",
	"menu_delete": "Supprimer",
	"menu_settings": "Paramètres",
	"menu_language": "Langue",
	"menu_exit": "Quitter",
	"menu_actions_title": "ACTIONS",

	"dashboard_welcome": "Bienvenue sur EasySave",
	"dashboard_subtitle": "Votre solution de sauvegarde fiable",
	"dashboard_status": "Statut",
	"dashboard_jobs_count": "travaux de sauvegarde",

	"theme_dark": "Thème sombre",
	"theme_light": "Thème clair",

	"create_title": "Créer un nouveau travail de sauvegarde",
	"create_name": "Nom du travail :",
	"create_source": "Chemin source :",
	"create_target": "Chemin cible :",
	"create_type": "Type de sauvegarde :",
	"create_button": "Créer",
	"create_success": "Travail de sauvegarde créé avec succès !",
	"create_failure": "Échec de la création du travail de sauvegarde. Limite maximale atteinte ou données invalides.",

	"execute_title": "Exécuter un travail de sauvegarde",
	"execute_subtitle": "Sélectionnez un travail pour démarrer la sauvegarde",
	"execute_placeholder": "Choisissez un travail de sauvegarde...",
	"execute_processing": "Traitement en cours...",
	"execute_select": "Sélectionnez un travail à exécuter :",
	"execute_button": "Exécuter",
	"execute_id": "Entrez l'ID du travail de sauvegarde à exécuter ",
	"execute_success": "Travail de sauvegarde terminé avec succès !",
	"execute_failure": "Échec de l'exécution du travail de sauvegarde ",
	"execute_all_title": "Exécuter tous les travaux",
	"execute_all_subtitle": "Tous les travaux seront exécutés séquentiellement",
	"execute_waiting": "En attente...",
	"execute_completed": "Terminé !",
	"execute_all_completed": "Tous les travaux ont été complétés avec succès !",
	"execute_all_start": "Exécution de tous les travaux de sauvegarde...",
	"execute_no_jobs": "Aucun travail de sauvegarde disponible. Créez-en un d'abord !",

	"list_title": "Tous les travaux de sauvegarde",
	"list_empty": "Aucun travail de sauvegarde trouvé.",
	"list_id": "ID :",
	"list_name": "Nom :",
	"list_source": "Source :",
	"list_target": "Cible :",
	"list_type": "Type :",
	"list_state": "État ",
	"list_last_exec": "Dernière Exécution ",

	"delete_title": "Supprimer un travail de sauvegarde",
	"delete_select": "Sélectionnez un travail à supprimer :",
	"delete_button": "Supprimer",
	"delete_warning": "⚠️ Attention : Cette action est permanente et ne peut pas être annulée !",
	"delete_no_jobs": "Aucun travail de sauvegarde disponible.",
	"delete_id": "Entrez l'ID du travail de sauvegarde à supprimer ",
	"delete_success": "Travail de sauvegarde supprimé avec succès !",
	"delete_failure": "Échec de la suppression du travail de sauvegarde.",

	"settings_title": "Paramètres",
	"settings_lang": "Langue :",
	"settings_window_mode": "Mode fenêtre :",
	"settings_window_windowed": "Fenêtré",
	"settings_window_maximized": "Plein écran (Maximisé)",
	"settings_window_fullscreen": "Plein écran (Sans bordure)",
	"settings_applied": "Paramètres appliqués avec succès !",
	"language_title": "Changer de langue",
	"language_select": "Sélectionnez la langue :",
	"language_apply": "Appliquer",
	"language_changed": "✓ Langue changée en Français !",

	"btn_save": "Enregistrer",
	"btn_cancel": "Annuler",
	"btn_apply": "Appliquer",
	"btn_delete": "Supprimer",
	"btn_start": "Démarrer la sauvegarde",
	"btn_start_all": "Tout Démarrer",
	"button_cancel": "Annuler",
	"button_back": "Retour au menu",

	"progress_active": "État : Actif",
	"progress_files": "Fichiers : {0}/{1}",
	"progress_size": "Taille : {0}/{1} octets",
	"progress_current": "Fichier actuel : {0}",
	"progress_percentage": "Progression : {0:F2}%",

	"press_enter": "Appuyez sur Entrée pour continuer...",
	"invalid_choice": "Choix invalide. Veuillez réessayer.",
	"error": "Erreur ",
	"type_complete": "Complète",
	"type_differential": "Différentielle",
	"state_active": "Actif",
	"state_inactive": "Inactif",
	"state_completed": "Terminé",
	"state_error": "Erreur",
	"never": "Jamais"
}
</file>

<file path="EasyConsole/View/Commands/ExecuteBackupJobCommand.cs">
using EasySave.Backup;
using EasySave.Extensions;
using EasyConsole.View.Command;
using EasySave.View.Localization;

namespace EasyConsole.View.Commands
{
    /// <summary>
    /// Command to execute a specific backup job.
    /// </summary>
    public class ExecuteBackupJobCommand : ICommand
    {

        /// <summary>
        /// Gets the unique identifier for the execute backup job command.
        /// </summary>
        /// <returns>The integer ID 2.</returns>
        public int GetID() => 2;

        /// <summary>
        /// Executes the workflow for running a single backup job.
        /// </summary>
        /// <remarks>
        /// This method clears the console, displays the list of available jobs (by invoking the List command),
        /// prompts the user for the ID of the job to execute, and triggers the execution via the BackupManager.
        /// It handles input validation and displays success or failure messages.
        /// </remarks>
        public void Execute()
        {
            Console.Clear();

            // Afficher la liste des processus de sauvegarde
            CommandContext.Instance.ExecuteCommand(4);

            Console.Write("{0}: ", I18n.Instance.GetString("execute_id"));

            int id = ConsoleExt.ReadDec();

            try
            {
                if (id > 0)
                {
                    bool success = BackupManager.GetBM().ExecuteJob(id, ConsoleView.DisplayProgress);

                    if (success)
                    {
                        Console.WriteLine(I18n.Instance.GetString("execute_success"));
                    }
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("{0}: ", I18n.Instance.GetString("execute_failure") + e.Message);
            }
        }

        /// <summary>
        /// Gets the localization key for the "Execute backup job" menu item.
        /// </summary>
        /// <returns>The string key "menu_execute".</returns>
        public string GetI18nKey() => "menu_execute";

    }
}
</file>

<file path="EasyGUI/ViewModels/MainWindowViewModel.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Styling;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using EasySave.Backup;
using EasySave.View.Localization; // Nécessaire pour I18n
using System;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Input;

namespace EasyGUI.ViewModels
{
    // Classe pour tracker la progression de chaque job
    public class JobProgressItem : ObservableObject
    {
        private string _jobName = "";
        public string JobName
        {
            get => _jobName;
            set => SetProperty(ref _jobName, value);
        }

        private double _progressPercentage = 0;
        public double ProgressPercentage
        {
            get => _progressPercentage;
            set => SetProperty(ref _progressPercentage, value);
        }

        private string _status = "Waiting...";
        public string Status
        {
            get => _status;
            set => SetProperty(ref _status, value);
        }

        private bool _isCompleted = false;
        public bool IsCompleted
        {
            get => _isCompleted;
            set => SetProperty(ref _isCompleted, value);
        }

        private bool _hasError = false;
        public bool HasError
        {
            get => _hasError;
            set => SetProperty(ref _hasError, value);
        }
    }

    public class MainWindowViewModel : ObservableObject
    {
        // --- GESTION DE LA TRADUCTION DYNAMIQUE ---
        // Cette propriété permet d'utiliser {Binding L[key]} dans le XAML
        public I18n L => I18n.Instance;

        public string Greeting { get; } = "Welcome to EasySave!";

        private readonly BackupManager _backupManager;

        // Liste des jobs affichée dans l'UI
        public ObservableCollection<BackupJob> BackupJobs { get; set; }

        // Navigation
        private string _currentView = "Menu";
        public string CurrentView
        {
            get => _currentView;
            set => SetProperty(ref _currentView, value);
        }

        // --- PROPRIÉTÉS DE FORMULAIRE ---
        private string _newJobName = "";
        public string NewJobName
        {
            get => _newJobName;
            set => SetProperty(ref _newJobName, value);
        }

        private string _newJobSource = "";
        public string NewJobSource
        {
            get => _newJobSource;
            set => SetProperty(ref _newJobSource, value);
        }

        private string _newJobTarget = "";
        public string NewJobTarget
        {
            get => _newJobTarget;
            set => SetProperty(ref _newJobTarget, value);
        }

        private int _selectedBackupType = 0;
        public int SelectedBackupType
        {
            get => _selectedBackupType;
            set => SetProperty(ref _selectedBackupType, value);
        }

        private BackupJob? _selectedJob;
        public BackupJob? SelectedJob
        {
            get => _selectedJob;
            set => SetProperty(ref _selectedJob, value);
        }

        private int _selectedLanguage = 0;
        public int SelectedLanguage
        {
            get => _selectedLanguage;
            set => SetProperty(ref _selectedLanguage, value);
        }

        private int _selectedWindowMode = 1; // 0=Windowed, 1=Maximized (défaut), 2=Fullscreen
        public int SelectedWindowMode
        {
            get
            {
                System.Diagnostics.Debug.WriteLine($"GET SelectedWindowMode = {_selectedWindowMode}");
                return _selectedWindowMode;
            }
            set
            {
                System.Diagnostics.Debug.WriteLine($"SET SelectedWindowMode from {_selectedWindowMode} to {value}");
                SetProperty(ref _selectedWindowMode, value);
            }
        }

        private string _statusMessage = "";
        public string StatusMessage
        {
            get => _statusMessage;
            set => SetProperty(ref _statusMessage, value);
        }

        private bool _isExecuting = false;
        public bool IsExecuting
        {
            get => _isExecuting;
            set => SetProperty(ref _isExecuting, value);
        }

        private double _currentProgress = 0;
        public double CurrentProgress
        {
            get => _currentProgress;
            set => SetProperty(ref _currentProgress, value);
        }

        private string _currentFileInfo = "";
        public string CurrentFileInfo
        {
            get => _currentFileInfo;
            set => SetProperty(ref _currentFileInfo, value);
        }

        // Collection pour la progression de tous les jobs
        public ObservableCollection<JobProgressItem> JobsProgress { get; private set; }

        // Propriétés pour les textes traduits
        private I18n _i18n = I18n.Instance;

        public string MenuTitle => _i18n.GetString("menu_title");
        public string MenuCreate => _i18n.GetString("menu_create");
        public string MenuExecute => _i18n.GetString("menu_execute");
        public string MenuExecuteAll => _i18n.GetString("menu_execute_all");
        public string MenuList => _i18n.GetString("menu_list");
        public string MenuDelete => _i18n.GetString("menu_delete");
        public string MenuLanguage => _i18n.GetString("menu_language");
        public string MenuExit => _i18n.GetString("menu_exit");

        public string ThemeDark => _i18n.GetString("theme_dark");
        public string ThemeLight => _i18n.GetString("theme_light");

        public string CreateTitle => _i18n.GetString("create_title");
        public string CreateName => _i18n.GetString("create_name");
        public string CreateSource => _i18n.GetString("create_source");
        public string CreateTarget => _i18n.GetString("create_target");
        public string CreateType => _i18n.GetString("create_type");
        public string CreateButton => _i18n.GetString("create_button");

        public string ExecuteTitle => _i18n.GetString("execute_title");
        public string ExecuteSelect => _i18n.GetString("execute_select");
        public string ExecuteButton => _i18n.GetString("execute_button");
        public string ExecuteNoJobs => _i18n.GetString("execute_no_jobs");

        public string ListTitle => _i18n.GetString("list_title");
        public string ListId => _i18n.GetString("list_id");
        public string ListName => _i18n.GetString("list_name");
        public string ListSource => _i18n.GetString("list_source");
        public string ListTarget => _i18n.GetString("list_target");

        public string DeleteTitle => _i18n.GetString("delete_title");
        public string DeleteSelect => _i18n.GetString("delete_select");
        public string DeleteButton => _i18n.GetString("delete_button");
        public string DeleteWarning => _i18n.GetString("delete_warning");
        public string DeleteNoJobs => _i18n.GetString("delete_no_jobs");

        public string LanguageTitle => _i18n.GetString("language_title");
        public string LanguageSelect => _i18n.GetString("language_select");
        public string LanguageApply => _i18n.GetString("language_apply");

        public string ButtonCancel => _i18n.GetString("button_cancel");
        public string ButtonBack => _i18n.GetString("button_back");

        public string TypeComplete => _i18n.GetString("type_complete");
        public string TypeDifferential => _i18n.GetString("type_differential");

        // Collection pour les types de backup dans la ComboBox
        public ObservableCollection<string> BackupTypes { get; private set; }

        // Collection pour les modes de fenêtre
        public ObservableCollection<string> WindowModes { get; private set; }

        public ICommand SwitchThemeCommand { get; }
        public ICommand CreateBackupJobCommand { get; }
        public ICommand ExecuteBackupJobCommand { get; }
        public ICommand ExecuteAllBackupJobsCommand { get; }
        public ICommand StartAllBackupJobsCommand { get; }
        public ICommand ListAllBackupJobsCommand { get; }
        public ICommand DeleteBackupJobCommand { get; }
        public ICommand ChangeLanguageCommand { get; }
        public ICommand OpenSettingsCommand { get; }
        public ICommand ExitCommand { get; }
        public ICommand BackToMenuCommand { get; }
        public ICommand SaveNewJobCommand { get; }
        public ICommand ExecuteSelectedJobCommand { get; }
        public ICommand DeleteSelectedJobCommand { get; }
        public ICommand ApplyLanguageCommand { get; }
        public ICommand ApplySettingsCommand { get; }

        public MainWindowViewModel()
        {
            // 1. Récupération du Singleton BackupManager
            _backupManager = BackupManager.GetBM();

            // 2. Initialisation de la liste observable
            var jobsFromManager = _backupManager.GetAllJobs();
            BackupJobs = new ObservableCollection<BackupJob>(jobsFromManager);

            // 2b. Initialiser la collection de progression
            JobsProgress = new ObservableCollection<JobProgressItem>();

            // 3. Initialiser la collection des types de backup
            BackupTypes = new ObservableCollection<string>
            {
                TypeComplete,
                TypeDifferential
            };

            // 4. Initialiser la collection des modes de fenêtre
            WindowModes = new ObservableCollection<string>
            {
                _i18n.GetString("settings_window_windowed"),
                _i18n.GetString("settings_window_maximized"),
                _i18n.GetString("settings_window_fullscreen")
            };

            // Initialize commands
            SwitchThemeCommand = new RelayCommand<string>(SwitchTheme);
            CreateBackupJobCommand = new RelayCommand(CreateBackupJob);
            ExecuteBackupJobCommand = new RelayCommand(ExecuteBackupJob);
            ExecuteAllBackupJobsCommand = new RelayCommand(ExecuteAllBackupJobs);
            StartAllBackupJobsCommand = new RelayCommand(StartAllBackupJobs);
            ListAllBackupJobsCommand = new RelayCommand(ListAllBackupJobs);
            DeleteBackupJobCommand = new RelayCommand(DeleteBackupJob);
            ChangeLanguageCommand = new RelayCommand(ChangeLanguage);
            OpenSettingsCommand = new RelayCommand(OpenSettings);
            ExitCommand = new RelayCommand(Exit);
            BackToMenuCommand = new RelayCommand(BackToMenu);
            SaveNewJobCommand = new RelayCommand(SaveNewJob);
            ExecuteSelectedJobCommand = new RelayCommand(ExecuteSelectedJob);
            DeleteSelectedJobCommand = new RelayCommand(DeleteSelectedJob);
            ApplyLanguageCommand = new RelayCommand(ApplyLanguage);
            ApplySettingsCommand = new RelayCommand(ApplySettings);
        }

        // --- MÉTHODES ---

        private void SwitchTheme(string? theme)
        {
            if (Application.Current is not null)
            {
                Application.Current.RequestedThemeVariant = theme switch
                {
                    "Light" => ThemeVariant.Light,
                    "Dark" => ThemeVariant.Dark,
                    _ => ThemeVariant.Default
                };
            }
        }

        private void RefreshBackupJobs()
        {
            BackupJobs.Clear();
            foreach (var job in _backupManager.GetAllJobs())
            {
                BackupJobs.Add(job);
            }
        }

        private void BackToMenu()
        {
            CurrentView = "Menu";
            StatusMessage = "";
        }

        private void CreateBackupJob()
        {
            CurrentView = "CreateJob";
            NewJobName = "";
            NewJobSource = "";
            NewJobTarget = "";
            SelectedBackupType = 0;
            StatusMessage = "";
        }

        private async void SaveNewJob()
        {
            BackupType type = SelectedBackupType == 0 ? BackupType.Complete : BackupType.Differential;
            bool success = _backupManager.AddJob(NewJobName, NewJobSource, NewJobTarget, type);

            if (success)
            {
                RefreshBackupJobs();
                StatusMessage = "✓ " + (_i18n.GetString("create_success") ?? "Job created successfully!");

                // Attendre 2 secondes pour afficher le message
                await Task.Delay(2000);

                // Réinitialiser le formulaire pour permettre de créer un nouveau job
                NewJobName = "";
                NewJobSource = "";
                NewJobTarget = "";
                SelectedBackupType = 0;
                StatusMessage = "";
            }
            else
            {
                StatusMessage = "✗ " + (_i18n.GetString("create_failure") ?? "Failed to create job. Check inputs or max limit.");
            }
        }

        private void ExecuteBackupJob()
        {
            RefreshBackupJobs();
            StatusMessage = "";
            CurrentView = "ExecuteJob";
        }

        private async void ExecuteSelectedJob()
        {
            if (SelectedJob != null)
            {
                IsExecuting = true;
                CurrentProgress = 0;
                CurrentFileInfo = "";
                int jobId = SelectedJob.Id;
                string jobName = SelectedJob.Name;
                StatusMessage = $"Executing '{jobName}'...";

                await Task.Run(() =>
                {
                    try
                    {
                        // Exécution dans un thread séparé pour ne pas bloquer l'UI
                        _backupManager.ExecuteJob(jobId, progress =>
                        {
                            // Mise à jour de la progression sur le thread UI
                            Avalonia.Threading.Dispatcher.UIThread.Post(() =>
                            {
                                CurrentProgress = progress.ProgressPercentage;
                                int filesProcessed = progress.TotalFiles - progress.FilesRemaining;
                                CurrentFileInfo = $"{filesProcessed}/{progress.TotalFiles} files";
                                StatusMessage = $"Running: {progress.ProgressPercentage:F1}% - {filesProcessed}/{progress.TotalFiles}";
                            });
                        });

                        // Mise à jour finale sur le thread UI
                        Avalonia.Threading.Dispatcher.UIThread.Post(() =>
                        {
                            RefreshBackupJobs();
                            SelectedJob = BackupJobs.FirstOrDefault(j => j.Id == jobId);
                            StatusMessage = $"✓ '{jobName}' completed!";
                            CurrentProgress = 100;
                            IsExecuting = false;
                        });
                    }
                    catch (Exception ex)
                    {
                        Avalonia.Threading.Dispatcher.UIThread.Post(() =>
                        {
                            IsExecuting = false;
                            StatusMessage = $"✗ Error: {ex.Message}";
                        });
                    }
                });
            }
            else
            {
                StatusMessage = "Please select a job.";
            }
        }

        private void ExecuteAllBackupJobs()
        {
            // Préparer la liste de progression
            JobsProgress.Clear();
            foreach (var job in BackupJobs)
            {
                JobsProgress.Add(new JobProgressItem 
                { 
                    JobName = job.Name,
                    Status = _i18n.GetString("execute_waiting") ?? "Waiting...",
                    ProgressPercentage = 0
                });
            }

            CurrentView = "ExecuteAll";
            IsExecuting = false;
            StatusMessage = "";
        }

        private async void StartAllBackupJobs()
        {
            IsExecuting = true;
            StatusMessage = "";

            await Task.Run(() =>
            {
                try
                {
                    _backupManager.ExecuteAllJobs(progress =>
                    {
                        // Trouver le job correspondant dans JobsProgress
                        var progressItem = JobsProgress.FirstOrDefault(j => j.JobName == progress.BackupName);
                        if (progressItem != null)
                        {
                            progressItem.ProgressPercentage = progress.ProgressPercentage;
                            int filesCopied = progress.TotalFiles - progress.FilesRemaining;
                            progressItem.Status = $"{progress.ProgressPercentage:F1}% - {filesCopied}/{progress.TotalFiles} files";

                            // Si terminé à 100%
                            if (progress.ProgressPercentage >= 100)
                            {
                                progressItem.IsCompleted = true;
                                progressItem.Status = _i18n.GetString("execute_completed") ?? "Completed!";
                            }
                        }
                    });

                    // Marquer tous comme terminés
                    foreach (var item in JobsProgress.Where(j => !j.IsCompleted && !j.HasError))
                    {
                        item.IsCompleted = true;
                        item.ProgressPercentage = 100;
                        item.Status = _i18n.GetString("execute_completed") ?? "Completed!";
                    }

                    RefreshBackupJobs();
                    StatusMessage = "✓ " + (_i18n.GetString("execute_all_completed") ?? "All jobs completed!");
                }
                catch (Exception ex)
                {
                    StatusMessage = $"✗ Error: {ex.Message}";

                    // Marquer les jobs non terminés comme erreur
                    foreach (var item in JobsProgress.Where(j => !j.IsCompleted))
                    {
                        item.HasError = true;
                        item.Status = "Error";
                    }
                }
                finally
                {
                    IsExecuting = false;
                }
            });
        }

        private void ListAllBackupJobs()
        {
            RefreshBackupJobs();
            StatusMessage = "";
            CurrentView = "ListJobs";
        }

        private void DeleteBackupJob()
        {
            RefreshBackupJobs();
            StatusMessage = "";
            CurrentView = "DeleteJob";
        }

        private async void DeleteSelectedJob()
        {
            if (SelectedJob != null)
            {
                string jobName = SelectedJob.Name;
                bool success = _backupManager.DeleteJob(SelectedJob.Id);
                if (success)
                {
                    RefreshBackupJobs();
                    StatusMessage = $"✓ '{jobName}' deleted!";

                    // Attendre 2 secondes pour afficher le message
                    await Task.Delay(2000);

                    // Réinitialiser la sélection et le message
                    SelectedJob = null;
                    StatusMessage = "";
                }
                else
                {
                    StatusMessage = "✗ Failed to delete.";
                }
            }
            else
            {
                StatusMessage = "Select a job first.";
            }
        }

        private void ChangeLanguage()
        {
            // On charge la langue actuelle dans le sélecteur
            // Si la langue est "fr_fr", l'index est 1, sinon 0
            SelectedLanguage = I18n.Instance.Language == "fr_fr" ? 1 : 0;

            CurrentView = "ChangeLanguage";
            StatusMessage = "";
        }

        private void OpenSettings()
        {
            // Charger les paramètres actuels
            SelectedLanguage = I18n.Instance.Language == "fr_fr" ? 1 : 0;

            // Détecter le mode de fenêtre actuel
            if (Application.Current?.ApplicationLifetime is Avalonia.Controls.ApplicationLifetimes.IClassicDesktopStyleApplicationLifetime desktop)
            {
                var mainWindow = desktop.MainWindow;
                if (mainWindow != null)
                {
                    // Si ExtendClientArea est actif, c'est le mode fullscreen sans bordure
                    if (mainWindow.ExtendClientAreaToDecorationsHint)
                    {
                        SelectedWindowMode = 2;
                    }
                    else if (mainWindow.WindowState == WindowState.Maximized)
                    {
                        SelectedWindowMode = 1;
                    }
                    else
                    {
                        SelectedWindowMode = 0;
                    }
                }
            }

            CurrentView = "Settings";
            StatusMessage = "";
        }

        private async void ApplySettings()
        {
            try
            {
                // IMPORTANT: Sauvegarder SelectedWindowMode AVANT de changer la langue
                // car RefreshTranslations() va réinitialiser la ComboBox
                int savedWindowMode = SelectedWindowMode;

                // Appliquer la langue
                var i18n = I18n.Instance;
                string languageCode = SelectedLanguage == 0 ? "en_us" : "fr_fr";
                i18n.SetLanguage(languageCode);
                RefreshTranslations();

                // Restaurer SelectedWindowMode après le refresh
                SelectedWindowMode = savedWindowMode;

                // Appliquer le mode de fenêtre
                if (Application.Current?.ApplicationLifetime is Avalonia.Controls.ApplicationLifetimes.IClassicDesktopStyleApplicationLifetime desktop)
                {
                    var mainWindow = desktop.MainWindow;
                    if (mainWindow != null)
                    {
                        switch (SelectedWindowMode)
                        {
                            case 0: // Windowed (Normal)
                                mainWindow.ExtendClientAreaToDecorationsHint = false;
                                await Task.Delay(50);
                                mainWindow.WindowState = WindowState.Normal;
                                break;

                            case 1: // Maximized (avec bordures)
                                mainWindow.ExtendClientAreaToDecorationsHint = false;
                                await Task.Delay(50);
                                mainWindow.WindowState = WindowState.Maximized;
                                break;

                            case 2: // Fullscreen sans bordure
                                mainWindow.ExtendClientAreaToDecorationsHint = true;
                                mainWindow.ExtendClientAreaTitleBarHeightHint = -1;
                                mainWindow.ExtendClientAreaChromeHints = Avalonia.Platform.ExtendClientAreaChromeHints.NoChrome;
                                await Task.Delay(50);
                                mainWindow.WindowState = WindowState.Maximized;
                                break;
                        }
                    }
                }

                // Afficher message de confirmation
                StatusMessage = "✓ " + i18n.GetString("settings_applied");
                await Task.Delay(2000);
                StatusMessage = "";
            }
            catch (Exception ex)
            {
                StatusMessage = $"✗ Error: {ex.Message}";
            }
        }

        private void ApplyLanguage()
        {
            try
            {
                // Récupérer l'instance I18n
                var i18n = I18n.Instance;

                // Appliquer la langue sélectionnée
                string languageCode = SelectedLanguage == 0 ? "en_us" : "fr_fr";
                i18n.SetLanguage(languageCode);

                // Notifier toutes les propriétés de traduction pour rafraîchir l'interface
                RefreshTranslations();

                // Afficher le message dans la langue nouvellement sélectionnée
                StatusMessage = i18n.GetString("language_changed");

                // Attendre un peu pour que l'utilisateur voie le message
                System.Threading.Thread.Sleep(1000);

                CurrentView = "Menu";
                StatusMessage = "";
            }
            catch (Exception ex)
            {
                StatusMessage = $"✗ Error changing language: {ex.Message}";
            }
        }

        private void RefreshTranslations()
        {
            // L'objet I18n notifie maintenant automatiquement ses propres changements (Item[])
            // On notifie quand même L au cas où certains bindings en auraient besoin
            OnPropertyChanged(nameof(L));

            // Mettre à jour la collection BackupTypes avec les nouvelles traductions
            BackupTypes.Clear();
            BackupTypes.Add(TypeComplete);
            BackupTypes.Add(TypeDifferential);

            // Mettre à jour la collection WindowModes avec les nouvelles traductions
            WindowModes.Clear();
            WindowModes.Add(_i18n.GetString("settings_window_windowed"));
            WindowModes.Add(_i18n.GetString("settings_window_maximized"));
            WindowModes.Add(_i18n.GetString("settings_window_fullscreen"));

            // Notifier les propriétés individuelles qui sont encore utilisées
            OnPropertyChanged(nameof(TypeComplete));
            OnPropertyChanged(nameof(TypeDifferential));
        }

        private void Exit()
        {
            if (Application.Current?.ApplicationLifetime is Avalonia.Controls.ApplicationLifetimes.IClassicDesktopStyleApplicationLifetime desktop)
            {
                desktop.Shutdown();
            }
        }
    }
}
</file>

<file path="EasyGUI/Views/MainWindow.axaml">
<Window xmlns="https://github.com/avaloniaui"
		xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
		xmlns:vm="using:EasyGUI.ViewModels"
		xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
		xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
		mc:Ignorable="d" d:DesignWidth="1000" d:DesignHeight="700"
		x:Class="EasyGUI.Views.MainWindow"
		x:Name="MainWindowRoot"
		x:DataType="vm:MainWindowViewModel"
		Icon="/Assets/avalonia-logo.ico"
		Title="ProSoft EasySave 3.0"
		Width="1200"
		Height="750"
		MinWidth="900"
		MinHeight="600"
		WindowState="Maximized"
		WindowStartupLocation="CenterScreen">

	<Design.DataContext>
		<vm:MainWindowViewModel/>
	</Design.DataContext>

	<Grid ColumnDefinitions="260, *">

		<Border Grid.Column="0" Classes="Sidebar">
			<Grid RowDefinitions="Auto, *, Auto">

				<StackPanel Grid.Row="0" Margin="0,30,0,40">
					<TextBlock Text="EasySave" HorizontalAlignment="Center" FontSize="28" FontWeight="Bold" Foreground="#F6E05E"/>
					<TextBlock Text="{Binding L[app_title]}" HorizontalAlignment="Center" FontSize="12" Opacity="0.6"/>
				</StackPanel>

				<StackPanel Grid.Row="1" Spacing="5">

					<Button Classes="NavButton" Command="{Binding BackToMenuCommand}">
						<TextBlock Text="{Binding L[menu_dashboard]}"/>
					</Button>

					<Separator Height="1" Margin="20,10"/>
					<TextBlock Text="{Binding L[menu_actions_title]}" FontSize="10" FontWeight="Bold" Opacity="0.5" Margin="25,0,0,5"/>

					<Button Classes="NavButton" Command="{Binding CreateBackupJobCommand}">
						<TextBlock Text="{Binding L[menu_create]}"/>
					</Button>

					<Button Classes="NavButton" Command="{Binding ExecuteBackupJobCommand}">
						<TextBlock Text="{Binding L[menu_execute]}"/>
					</Button>

					<Button Classes="NavButton" Command="{Binding ExecuteAllBackupJobsCommand}">
						<TextBlock Text="{Binding L[menu_execute_all]}"/>
					</Button>

					<Button Classes="NavButton" Command="{Binding ListAllBackupJobsCommand}">
						<TextBlock Text="{Binding L[menu_list]}"/>
					</Button>

					<Button Classes="NavButton" Command="{Binding DeleteBackupJobCommand}">
						<TextBlock Text="{Binding L[menu_delete]}"/>
					</Button>
				</StackPanel>

				<StackPanel Grid.Row="2" Margin="0,0,0,20">
					<Button Classes="NavButton" Command="{Binding OpenSettingsCommand}">
						<TextBlock Text="{Binding L[menu_settings]}"/>
					</Button>
					<Button Classes="NavButton" Command="{Binding ExitCommand}" Foreground="#FC8181">
						<TextBlock Text="{Binding L[menu_exit]}"/>
					</Button>
				</StackPanel>
			</Grid>
		</Border>

		<Grid Grid.Column="1" RowDefinitions="Auto, *" Name="MainContentArea" Background="{DynamicResource AppBackgroundBrush}">

			<Border Grid.Row="0" Height="60" BoxShadow="0 2 5 0 #05000000">
				<Grid ColumnDefinitions="*, Auto" Margin="30,0">
					<StackPanel Grid.Column="1" Orientation="Horizontal" Spacing="10">
						<Button Content="{Binding L[theme_dark]}" 
								Command="{Binding SwitchThemeCommand}" 
								CommandParameter="Dark" 
								Background="Transparent" 
								BorderThickness="0"
								IsVisible="{Binding $parent[Window].ActualThemeVariant, Converter={x:Static ObjectConverters.Equal}, ConverterParameter={x:Static ThemeVariant.Light}}"/>
						<Button Content="{Binding L[theme_light]}" 
								Command="{Binding SwitchThemeCommand}" 
								CommandParameter="Light" 
								Background="Transparent" 
								BorderThickness="0"
								IsVisible="{Binding $parent[Window].ActualThemeVariant, Converter={x:Static ObjectConverters.Equal}, ConverterParameter={x:Static ThemeVariant.Dark}}"/>
					</StackPanel>
				</Grid>
			</Border>

			<Panel Grid.Row="1" Margin="10">

				<Border Classes="Card" IsVisible="{Binding CurrentView, Converter={x:Static ObjectConverters.Equal}, ConverterParameter=Menu}">
					<StackPanel VerticalAlignment="Center" HorizontalAlignment="Center" Spacing="20">
						<TextBlock Text="{Binding L[dashboard_welcome]}" FontSize="32" FontWeight="Bold" HorizontalAlignment="Center"/>
						<TextBlock Text="{Binding L[dashboard_subtitle]}" FontSize="18" HorizontalAlignment="Center" Opacity="0.7"/>
					</StackPanel>
				</Border>

				<Border Classes="Card" IsVisible="{Binding CurrentView, Converter={x:Static ObjectConverters.Equal}, ConverterParameter=CreateJob}">
					<StackPanel Spacing="20" MaxWidth="500">
						<TextBlock Text="{Binding L[create_title]}" FontSize="24" FontWeight="Bold"/>
						<Separator/>

						<StackPanel Spacing="5">
							<TextBlock Text="{Binding L[create_name]}" FontWeight="Medium"/>
							<TextBox Text="{Binding NewJobName}"/>
						</StackPanel>

						<StackPanel Spacing="5">
							<TextBlock Text="{Binding L[create_source]}" FontWeight="Medium"/>
							<TextBox Text="{Binding NewJobSource}"/>
						</StackPanel>

						<StackPanel Spacing="5">
							<TextBlock Text="{Binding L[create_target]}" FontWeight="Medium"/>
							<TextBox Text="{Binding NewJobTarget}"/>
						</StackPanel>

						<StackPanel Spacing="5">
							<TextBlock Text="{Binding L[create_type]}" FontWeight="Medium"/>
							<ComboBox SelectedIndex="{Binding SelectedBackupType}" 
									  ItemsSource="{Binding BackupTypes}"
									  HorizontalAlignment="Stretch"/>
						</StackPanel>

						<TextBlock Text="{Binding StatusMessage}" Foreground="Red" TextWrapping="Wrap"/>

						<StackPanel Orientation="Horizontal" Spacing="15" Margin="0,20,0,0">
							<Button Classes="Primary" Content="{Binding L[btn_save]}" Command="{Binding SaveNewJobCommand}"/>
							<Button Content="{Binding L[btn_cancel]}" Command="{Binding BackToMenuCommand}" Background="Transparent"/>
						</StackPanel>
					</StackPanel>
				</Border>

				<Border Classes="Card" IsVisible="{Binding CurrentView, Converter={x:Static ObjectConverters.Equal}, ConverterParameter=ExecuteJob}">
						<StackPanel Spacing="20" MaxWidth="600">
							<StackPanel>
								<TextBlock Text="{Binding L[execute_title]}" FontSize="24" FontWeight="Bold"/>
								<TextBlock Text="{Binding L[execute_subtitle]}" Opacity="0.7" Margin="0,5,0,0"/>
							</StackPanel>

							<Separator/>

							<ComboBox ItemsSource="{Binding BackupJobs}"
									  SelectedItem="{Binding SelectedJob}"
									  HorizontalAlignment="Stretch"
									  PlaceholderText="{Binding L[execute_placeholder]}">
								<ComboBox.ItemTemplate>
									<DataTemplate>
										<TextBlock Text="{Binding Name}" FontWeight="Bold"/>
									</DataTemplate>
								</ComboBox.ItemTemplate>
							</ComboBox>

							<!-- Carte de progression (visible pendant l'exécution) -->
							<Border CornerRadius="8" 
									Padding="15" 
									BorderThickness="1" 
									BorderBrush="{DynamicResource SystemControlForegroundBaseMediumLowBrush}"
									IsVisible="{Binding IsExecuting}">
								<StackPanel Spacing="10">
									<!-- Nom du job en cours -->
									<Grid ColumnDefinitions="*, Auto">
										<TextBlock Grid.Column="0" 
												   Text="{Binding SelectedJob.Name}" 
												   FontWeight="SemiBold" 
												   FontSize="16"/>
										<TextBlock Grid.Column="1" 
												   Text="{Binding CurrentFileInfo}" 
												   FontSize="12" 
												   Opacity="0.7" 
												   VerticalAlignment="Center"/>
									</Grid>

									<!-- Barre de progression -->
									<ProgressBar Value="{Binding CurrentProgress}" 
												 Minimum="0"
												 Maximum="100"
												 Height="8" 
												 Foreground="#F6E05E"/>

									<!-- Status détaillé -->
									<TextBlock Text="{Binding StatusMessage}" 
											   FontSize="12" 
											   Opacity="0.8"
											   TextWrapping="Wrap"/>
								</StackPanel>
							</Border>

							<!-- Message de succès (visible après l'exécution) -->
							<TextBlock Text="{Binding StatusMessage}" 
									   Foreground="#48BB78"
									   FontWeight="SemiBold"
									   TextWrapping="Wrap"
									   IsVisible="{Binding !IsExecuting}"/>

							<!-- Bouton Start -->
							<Button Classes="Primary"
									Content="{Binding L[btn_start]}"
									Command="{Binding ExecuteSelectedJobCommand}"
									IsEnabled="{Binding !IsExecuting}"
									HorizontalAlignment="Stretch"
									HorizontalContentAlignment="Center"/>
						</StackPanel>
					</Border>

				<!-- Vue Execute All avec progression de chaque job -->
					<Border Classes="Card" IsVisible="{Binding CurrentView, Converter={x:Static ObjectConverters.Equal}, ConverterParameter=ExecuteAll}">
						<StackPanel Spacing="20" MaxWidth="800">
							<StackPanel>
								<TextBlock Text="{Binding L[execute_all_title]}" FontSize="24" FontWeight="Bold"/>
								<TextBlock Text="{Binding L[execute_all_subtitle]}" Opacity="0.7" Margin="0,5,0,0"/>
							</StackPanel>

							<Separator/>

							<!-- Liste des jobs avec leur progression -->
							<ScrollViewer MaxHeight="500">
								<ItemsControl ItemsSource="{Binding JobsProgress}">
									<ItemsControl.ItemTemplate>
										<DataTemplate>
											<Border CornerRadius="8" Padding="15" Margin="0,0,0,10" BorderThickness="1" BorderBrush="{DynamicResource SystemControlForegroundBaseMediumLowBrush}">
												<StackPanel Spacing="8">
													<!-- Nom du job et status -->
													<Grid ColumnDefinitions="*, Auto">
														<TextBlock Grid.Column="0" Text="{Binding JobName}" FontWeight="SemiBold" FontSize="16"/>
														<StackPanel Grid.Column="1" Orientation="Horizontal" Spacing="5">
															<!-- Icône succès -->
															<TextBlock Text="✓" Foreground="#48BB78" FontWeight="Bold" IsVisible="{Binding IsCompleted}"/>
															<!-- Icône erreur -->
															<TextBlock Text="✗" Foreground="#FC8181" FontWeight="Bold" IsVisible="{Binding HasError}"/>
															<!-- Texte status -->
															<TextBlock Text="{Binding Status}" FontSize="12" Opacity="0.7" VerticalAlignment="Center"/>
														</StackPanel>
													</Grid>

													<!-- Barre de progression -->
													<ProgressBar Value="{Binding ProgressPercentage}" 
																 Minimum="0" 
																 Maximum="100"
																 Height="8"
																 Foreground="#F6E05E"/>
												</StackPanel>
											</Border>
										</DataTemplate>
									</ItemsControl.ItemTemplate>
								</ItemsControl>
							</ScrollViewer>

							<!-- Message global -->
							<TextBlock Text="{Binding StatusMessage}" 
									   Foreground="#48BB78"
									   FontWeight="SemiBold"
									   TextWrapping="Wrap"
									   IsVisible="{Binding StatusMessage, Converter={x:Static StringConverters.IsNotNullOrEmpty}}"/>

							<!-- Bouton Start All -->
							<Button Classes="Primary"
									Content="{Binding L[btn_start_all]}"
									Command="{Binding StartAllBackupJobsCommand}"
									IsEnabled="{Binding !IsExecuting}"
									HorizontalAlignment="Stretch"
									HorizontalContentAlignment="Center"/>
						</StackPanel>
					</Border>

				<Border Classes="Card" IsVisible="{Binding CurrentView, Converter={x:Static ObjectConverters.Equal}, ConverterParameter=ListJobs}">
					<Grid RowDefinitions="Auto, *">
						<TextBlock Grid.Row="0" Text="{Binding L[list_title]}" FontSize="24" FontWeight="Bold" Margin="0,0,0,20"/>
						<ListBox Grid.Row="1" ItemsSource="{Binding BackupJobs}" Background="Transparent" BorderThickness="0">
							<ListBox.Styles>
								<Style Selector="ListBoxItem">
									<Setter Property="Padding" Value="0"/>
									<Setter Property="Margin" Value="0,0,0,10"/>
									<Setter Property="Background" Value="Transparent"/>
									<Setter Property="BorderThickness" Value="0"/>
								</Style>
								<Style Selector="ListBoxItem:selected /template/ ContentPresenter">
									<Setter Property="Background" Value="Transparent"/>
								</Style>
							</ListBox.Styles>
							<ListBox.ItemTemplate>
								<DataTemplate>
									<Border BorderThickness="0" CornerRadius="8" Padding="15" Background="{DynamicResource CardBackgroundFillColorDefaultBrush}">
										<Grid ColumnDefinitions="50, *, Auto">
											<Border Grid.Column="0" Background="#F6E05E" Width="40" Height="40" CornerRadius="20">
												<TextBlock Text="{Binding Id}" HorizontalAlignment="Center" VerticalAlignment="Center" FontWeight="Bold" Foreground="#2D3748"/>
											</Border>
											<StackPanel Grid.Column="1" Margin="15,0">
												<TextBlock Text="{Binding Name}" FontWeight="Bold" FontSize="16"/>
												<TextBlock Text="{Binding SourceDirectory}" FontSize="12" Opacity="0.7"/>
												<TextBlock Text="{Binding TargetDirectory}" FontSize="12" Opacity="0.7"/>
											</StackPanel>
											<Border Grid.Column="2" CornerRadius="4" Padding="10,5" VerticalAlignment="Center" Opacity="0.8">
												<TextBlock Text="{Binding Type}" FontSize="12" FontWeight="SemiBold"/>
											</Border>
										</Grid>
									</Border>
								</DataTemplate>
							</ListBox.ItemTemplate>
						</ListBox>
					</Grid>
				</Border>

				<Border Classes="Card" IsVisible="{Binding CurrentView, Converter={x:Static ObjectConverters.Equal}, ConverterParameter=DeleteJob}">
					<StackPanel Spacing="20" MaxWidth="500">
						<TextBlock Text="{Binding L[delete_title]}" FontSize="24" FontWeight="Bold" Foreground="#E53E3E"/>
						<TextBlock Text="{Binding L[delete_warning]}" Opacity="0.8"/>

						<ComboBox ItemsSource="{Binding BackupJobs}"
								 SelectedItem="{Binding SelectedJob}"
								 HorizontalAlignment="Stretch"
								 PlaceholderText="{Binding L[execute_placeholder]}">
							<ComboBox.ItemTemplate>
								<DataTemplate>
									<TextBlock Text="{Binding Name}"/>
								</DataTemplate>
							</ComboBox.ItemTemplate>
						</ComboBox>

						<!-- Message de statut -->
						<TextBlock Text="{Binding StatusMessage}" 
								   Foreground="#48BB78"
								   FontWeight="SemiBold"
								   TextWrapping="Wrap"
								   IsVisible="{Binding StatusMessage, Converter={x:Static StringConverters.IsNotNullOrEmpty}}"/>

						<Button Content="{Binding L[btn_delete]}"
								Background="#E53E3E"
								Foreground="White"
								Padding="20,10"
								CornerRadius="6"
								HorizontalAlignment="Stretch"
								HorizontalContentAlignment="Center"
								Command="{Binding DeleteSelectedJobCommand}"/>
					</StackPanel>
				</Border>

				<Border Classes="Card" IsVisible="{Binding CurrentView, Converter={x:Static ObjectConverters.Equal}, ConverterParameter=Settings}">
					<StackPanel Spacing="25" MaxWidth="500">
						<TextBlock Text="{Binding L[settings_title]}" FontSize="24" FontWeight="Bold"/>

						<Separator/>

						<!-- Section Langue -->
						<StackPanel Spacing="10">
							<TextBlock Text="{Binding L[settings_lang]}" FontWeight="SemiBold" FontSize="16"/>
							<ComboBox SelectedIndex="{Binding SelectedLanguage}" HorizontalAlignment="Stretch">
								<ComboBoxItem>English</ComboBoxItem>
								<ComboBoxItem>Français</ComboBoxItem>
							</ComboBox>
						</StackPanel>

						<Separator/>

						<!-- Section Mode Fenêtre -->
						<StackPanel Spacing="10">
							<TextBlock Text="{Binding L[settings_window_mode]}" FontWeight="SemiBold" FontSize="16"/>
							<ComboBox SelectedIndex="{Binding SelectedWindowMode}" 
									  ItemsSource="{Binding WindowModes}"
									  HorizontalAlignment="Stretch"/>
						</StackPanel>

						<!-- Message de confirmation -->
						<TextBlock Text="{Binding StatusMessage}" 
								   Foreground="#48BB78" 
								   FontWeight="SemiBold"
								   TextWrapping="Wrap"
								   IsVisible="{Binding StatusMessage, Converter={x:Static StringConverters.IsNotNullOrEmpty}}"/>

						<Button Classes="Primary" Content="{Binding L[btn_apply]}" Command="{Binding ApplySettingsCommand}" Margin="0,10,0,0"/>
					</StackPanel>
				</Border>

			</Panel>
		</Grid>
	</Grid>
</Window>
</file>

<file path="EasySave/default.json">
{
	"Version": "1.1.0",
	"MaxBackupJobs": 5,
	"UseBackupJobLimit": false,
	"LoggerFormat": "text",
	"CryptoSoftPath": "C:\\FISA_A3\\Bloc_Génie_Logiciel\\EasySave-Genie-Logiciel-Groupe-1\\EasyConsole\\bin\\Debug\\net8.0\\CryptoSoft.exe",
	"CryptoKey": "1234",
	"PriorityExtensions": [ ".txt", ".json", ".xml" ],
	"BusinessSoftware": "CalculatorApp"
}
</file>

<file path="EasySave/Backup/CompleteBackupStrategy.cs">
using EasyLog.Data;
using EasyLog.Logging;
using EasySave.Utils;
using Newtonsoft.Json.Linq;
using System.Diagnostics;

namespace EasySave.Backup
{
    /// <summary>
    /// Complete backup strategy - copies all files
    /// </summary>
    public class CompleteBackupStrategy : IBackupStrategy
    {

        /// <summary>
        /// Executes the specified backup job, copying all files from the source directory to the target directory and
        /// reporting progress through a callback.
        /// </summary>
        /// <remarks>
        /// The method creates the target directory if it does not already exist. The progress callback is
        /// invoked periodically with the current progress state, including after the operation completes. 
        /// If an error occurs while copying a file, the method logs the error with a negative execution time (-1) 
        /// and continues processing the remaining files.
        /// Paths are logged in UNC format.
        /// </remarks>
        /// <param name="job">The backup job to execute. Specifies the source and target directories, as well as backup metadata.</param>
        /// <param name="BusinessSoftware">The name of the business software to check for. If running, the backup may be aborted.</param>
        /// <param name="progressCallback">A callback method that receives progress updates as the backup operation proceeds. Can be null if progress
        /// reporting is not required.</param>
        /// <exception cref="DirectoryNotFoundException">Thrown if the source directory specified in the backup job does not exist.</exception>
        public void Execute(BackupJob job, string BusinessSoftware, Action<ProgressState> progressCallback)
        {
            if (!Directory.Exists(job.SourceDirectory))
            {
                BackupManager.GetLogger().Log(new LogEntry { Level = Level.Warning, Message = $"{job.Name} - Source directory does not exist: {job.SourceDirectory}" });
                throw new DirectoryNotFoundException($"Source directory not found: {job.SourceDirectory}");
            }

            if (!Directory.Exists(job.TargetDirectory))
                Directory.CreateDirectory(job.TargetDirectory);

            var files = Directory.GetFiles(job.SourceDirectory, "*", SearchOption.AllDirectories);
            var totalFiles = files.Length;
            long totalSize = 0;

            foreach (var file in files)
            {
                var fileInfo = new FileInfo(file);
                totalSize += fileInfo.Length;
            }

            var config = BackupManager.GetBM().ConfigManager;
            string cryptoPath = config.GetConfig("CryptoSoftPath")?.ToString() ?? "";
            string cryptoKey = config.GetConfig("CryptoKey")?.ToString() ?? "Key";
            var extensionsArray = config.GetConfig("PriorityExtensions") as JArray;
            List<string> extensions = extensionsArray?.ToObject<List<string>>() ?? [];

            if (!string.IsNullOrEmpty(BusinessSoftware) && Process.GetProcessesByName(BusinessSoftware).Length > 0)
            {
                string msg = $"[BLOCK] Logiciel métier détecté : '{BusinessSoftware}'. Sauvegarde annulée.";
                BackupManager.GetLogger().Log(new LogEntry
                {
                    Level = Level.Warning,
                    Message = $"Backup {job.Name} aborted: Business software '{BusinessSoftware}' is running."
                });

                job.State = State.Error;
                progressCallback?.Invoke(new ProgressState
                {
                    BackupName = job.Name,
                    State = State.Error,
                    Message = msg
                });

                return;
            }

            int processedFiles = 0;
            long processedSize = 0;

            foreach (var sourceFile in files)
            {
                if (!string.IsNullOrEmpty(BusinessSoftware) && Process.GetProcessesByName(BusinessSoftware).Length > 0)
                {
                    string msg = $"[STOP] Logiciel métier détecté : '{BusinessSoftware}'. Sauvegarde interrompue.";
                    BackupManager.GetLogger().Log(new LogEntry
                    {
                        Level = Level.Warning,
                        Message = $"Backup {job.Name} stopped: Business software '{BusinessSoftware}' detected during execution."
                    });

                    job.State = State.Error;

                    progressCallback?.Invoke(new ProgressState
                    {
                        BackupName = job.Name,
                        State = State.Error,
                        Message = msg
                    });

                    break;
                }

                var relativePath = Path.GetRelativePath(job.SourceDirectory, sourceFile);
                var targetFile = Path.Combine(job.TargetDirectory, relativePath);
                var targetDir = Path.GetDirectoryName(targetFile);

                if (!string.IsNullOrEmpty(targetDir) && !Directory.Exists(targetDir))
                    Directory.CreateDirectory(targetDir);

                var fileInfo = new FileInfo(sourceFile);
                var fileSize = fileInfo.Length;

                // Update progress state
                var progressState = new ProgressState
                {
                    BackupName = job.Name,
                    State = State.Active,
                    TotalFiles = totalFiles,
                    TotalSize = totalSize,
                    FilesRemaining = totalFiles - processedFiles,
                    SizeRemaining = totalSize - processedSize,
                    CurrentSourceFile = sourceFile,
                    CurrentTargetFile = targetFile,
                    ProgressPercentage = (double)processedFiles / totalFiles * 100
                };

                progressCallback?.Invoke(progressState);

                // Copy file and measure time
                var stopwatch = Stopwatch.StartNew();
                int encryptionTime = 0;

                try
                {
                    File.Copy(sourceFile, targetFile, true);
                    string ext = Path.GetExtension(targetFile);
                    if (File.Exists(cryptoPath) && extensions.Contains(ext))
                    {
                        var p = new Process();
                        p.StartInfo.FileName = cryptoPath;
                        p.StartInfo.Arguments = $"\"{targetFile}\" \"{cryptoKey}\"";
                        p.StartInfo.UseShellExecute = false;
                        p.StartInfo.CreateNoWindow = true;
                        p.Start();
                        p.WaitForExit();

                        encryptionTime = p.ExitCode;
                    }
                    stopwatch.Stop();

                    // Convert paths to UNC before logging
                    string uncSource = PathUtils.ToUnc(sourceFile);
                    string uncTarget = PathUtils.ToUnc(targetFile);

                    BackupManager.GetLogger().Log(new LogEntry
                    {
                        Name = job.Name,
                        SourceFile = uncSource,
                        TargetFile = uncTarget,
                        FileSize = fileSize,
                        ElapsedTime = stopwatch.ElapsedMilliseconds,
                        EncryptionTime = encryptionTime
                    });
                }
                catch (Exception e)
                {
                    stopwatch.Stop();

                    // Convert paths to UNC for the error log
                    string uncSource = PathUtils.ToUnc(sourceFile);
                    string uncTarget = PathUtils.ToUnc(targetFile);

                    // 1. Log the structured entry with negative time (-1) as per specification
                    BackupManager.GetLogger().Log(new LogEntry
                    {
                        Name = job.Name,
                        SourceFile = uncSource,
                        TargetFile = uncTarget,
                        FileSize = fileSize,
                        ElapsedTime = -1, // Indicates error
                        EncryptionTime = 0,
                        Level = Level.Error,
                        Message = $"Copy failed: {e.Message}"
                    });

                    // 2. Log the full stack trace for debugging
                    BackupManager.GetLogger().LogError(e);
                }

                processedFiles++;
                processedSize += fileSize;
            }

            // Final progress state
            if (job.State != State.Error)
            {
                var finalState = new ProgressState
                {
                    BackupName = job.Name,
                    State = State.Completed,
                    TotalFiles = totalFiles,
                    TotalSize = totalSize,
                    FilesRemaining = 0,
                    SizeRemaining = 0,
                    ProgressPercentage = 100
                };
                progressCallback?.Invoke(finalState);
            }
        }
    }
}
</file>

<file path="EasySave/Backup/DifferentialBackupStrategy.cs">
using EasyLog.Data;
using EasyLog.Logging;
using EasySave.Utils;
using Newtonsoft.Json.Linq;
using System.Diagnostics;

namespace EasySave.Backup
{
    /// <summary>
    /// Differential backup strategy - copies only modified files
    /// </summary>
    public class DifferentialBackupStrategy : IBackupStrategy
    {

        /// <summary>
        /// Executes the specified backup job, copying files from the source directory to the target directory and reporting
        /// progress through a callback.
        /// </summary>
        /// <remarks>
        /// The method performs a differential backup, copying only files that are new or have changed since
        /// the last backup. The target directory is created if it does not exist. The progress callback is invoked multiple
        /// times during execution, including a final call when the backup is complete. 
        /// If an error occurs, it is logged with a negative elapsed time (-1).
        /// Paths are logged in UNC format.
        /// </remarks>
        /// <param name="job">The backup job to execute. Specifies the source and target directories, as well as job metadata.</param>
        /// <param name="BusinessSoftware">The name of the business software to check for. If running, the backup may be aborted.</param>
        /// <param name="progressCallback">A callback that receives progress updates as the backup operation proceeds. The callback is invoked with a <see
        /// cref="ProgressState"/> object representing the current state of the backup. Can be <see langword="null"/> if
        /// progress updates are not required.</param>
        /// <exception cref="DirectoryNotFoundException">Thrown if the source directory specified in <paramref name="job"/> does not exist.</exception>
        public void Execute(BackupJob job, string BusinessSoftware, Action<ProgressState> progressCallback)
        {
            if (!Directory.Exists(job.SourceDirectory))
            {
                BackupManager.GetLogger().Log(new LogEntry { Level = Level.Warning, Message = $"{job.Name} - Source directory does not exist: {job.SourceDirectory}" });
                throw new DirectoryNotFoundException($"Source directory not found: {job.SourceDirectory}");
            }

            if (!Directory.Exists(job.TargetDirectory))
                Directory.CreateDirectory(job.TargetDirectory);

            var files = Directory.GetFiles(job.SourceDirectory, "*", SearchOption.AllDirectories);
            var totalFiles = files.Length;
            long totalSize = 0;

            foreach (var file in files)
            {
                var fileInfo = new FileInfo(file);
                totalSize += fileInfo.Length;
            }

            var config = BackupManager.GetBM().ConfigManager;
            string cryptoPath = config.GetConfig("CryptoSoftPath")?.ToString() ?? "";
            string cryptoKey = config.GetConfig("CryptoKey")?.ToString() ?? "Key";
            var extensionsArray = config.GetConfig("PriorityExtensions") as JArray;
            List<string> extensions = extensionsArray?.ToObject<List<string>>() ?? [];

            if (!string.IsNullOrEmpty(BusinessSoftware) && Process.GetProcessesByName(BusinessSoftware).Length > 0)
            {
                string msg = $"[BLOCK] Logiciel métier détecté : '{BusinessSoftware}'. Sauvegarde annulée.";
                BackupManager.GetLogger().Log(new LogEntry
                {
                    Level = Level.Warning,
                    Message = $"Backup {job.Name} aborted: Business software '{BusinessSoftware}' is running."
                });
                job.State = State.Error;
                progressCallback?.Invoke(new ProgressState
                {
                    BackupName = job.Name,
                    State = State.Error,
                    Message = msg
                });
                return;
            }

            int processedFiles = 0;
            long processedSize = 0;
            int copiedFiles = 0;

            foreach (var sourceFile in files)
            {
                if (!string.IsNullOrEmpty(BusinessSoftware) && Process.GetProcessesByName(BusinessSoftware).Length > 0)
                {
                    BackupManager.GetLogger().Log(new LogEntry
                    {
                        Level = Level.Warning,
                        Message = $"Backup {job.Name} stopped: Business software '{BusinessSoftware}' detected during execution."
                    });
                    job.State = State.Error;
                    break;
                }

                var relativePath = Path.GetRelativePath(job.SourceDirectory, sourceFile);
                var targetFile = Path.Combine(job.TargetDirectory, relativePath);
                var targetDir = Path.GetDirectoryName(targetFile);

                if (!string.IsNullOrEmpty(targetDir) && !Directory.Exists(targetDir))
                    Directory.CreateDirectory(targetDir);

                var sourceFileInfo = new FileInfo(sourceFile);
                var fileSize = sourceFileInfo.Length;
                bool needsCopy = false;

                // Check if file needs to be copied (differential logic)
                if (!File.Exists(targetFile))
                    needsCopy = true;
                else
                {
                    var targetFileInfo = new FileInfo(targetFile);

                    // Copy if source is newer or size is different
                    if (sourceFileInfo.LastWriteTime > targetFileInfo.LastWriteTime ||
                        sourceFileInfo.Length != targetFileInfo.Length)
                    {
                        needsCopy = true;
                    }
                }

                // Update progress state
                var progressState = new ProgressState
                {
                    BackupName = job.Name,
                    State = State.Active,
                    TotalFiles = totalFiles,
                    TotalSize = totalSize,
                    FilesRemaining = totalFiles - processedFiles,
                    SizeRemaining = totalSize - processedSize,
                    CurrentSourceFile = sourceFile,
                    CurrentTargetFile = targetFile,
                    ProgressPercentage = (double)processedFiles / totalFiles * 100
                };

                progressCallback?.Invoke(progressState);

                if (needsCopy)
                {
                    // Copy file and measure time
                    var stopwatch = Stopwatch.StartNew();
                    int encryptionTime = 0;

                    try
                    {
                        File.Copy(sourceFile, targetFile, true);
                        string ext = Path.GetExtension(targetFile);
                        if (File.Exists(cryptoPath) && extensions.Contains(ext))
                        {
                            var p = new Process();
                            p.StartInfo.FileName = cryptoPath;
                            p.StartInfo.Arguments = $"\"{targetFile}\" \"{cryptoKey}\"";
                            p.StartInfo.UseShellExecute = false;
                            p.StartInfo.CreateNoWindow = true;
                            p.Start();
                            p.WaitForExit();
                            encryptionTime = p.ExitCode;
                        }
                        stopwatch.Stop();

                        // Convert paths to UNC before logging
                        string uncSource = PathUtils.ToUnc(sourceFile);
                        string uncTarget = PathUtils.ToUnc(targetFile);

                        BackupManager.GetLogger().Log(new LogEntry
                        {
                            Name = job.Name,
                            SourceFile = uncSource,
                            TargetFile = uncTarget,
                            FileSize = fileSize,
                            ElapsedTime = stopwatch.ElapsedMilliseconds,
                            EncryptionTime = encryptionTime
                        });
                        copiedFiles++;
                    }
                    catch (Exception e)
                    {
                        stopwatch.Stop();

                        // Convert paths to UNC for the error log
                        string uncSource = PathUtils.ToUnc(sourceFile);
                        string uncTarget = PathUtils.ToUnc(targetFile);

                        // 1. Log the structured entry with negative time (-1) as per specification
                        BackupManager.GetLogger().Log(new LogEntry
                        {
                            Name = job.Name,
                            SourceFile = uncSource,
                            TargetFile = uncTarget,
                            FileSize = fileSize,
                            ElapsedTime = -1, // Indicates error
                            EncryptionTime = 0,
                            Level = Level.Error,
                            Message = $"Copy failed: {e.Message}"
                        });

                        // 2. Log the full stack trace for debugging
                        BackupManager.GetLogger().LogError(e);
                    }
                }

                processedFiles++;
                processedSize += fileSize;
            }

            // Final progress state
            if (job.State != State.Error)
            {
                var finalState = new ProgressState
                {
                    BackupName = job.Name,
                    State = State.Completed,
                    TotalFiles = totalFiles,
                    TotalSize = totalSize,
                    FilesRemaining = 0,
                    SizeRemaining = 0,
                    ProgressPercentage = 100
                };

                progressCallback?.Invoke(finalState);
            }
        }
    }
}
</file>

<file path="EasySave/Backup/BackupJob.cs">
using System.Text.Json.Serialization;

namespace EasySave.Backup
{
	/// <summary>
	/// Represents a backup job configuration
	/// </summary>
	/// <remarks>
	/// Initializes a new instance of the BackupJob class with the specified job details and backup type.
	/// </remarks>
	/// <param name="Id">The unique identifier for the backup job.</param>
	/// <param name="Name">The name assigned to the backup job. Cannot be null or empty.</param>
	/// <param name="SourceDirectory">The path to the source directory to be backed up. Must be a valid directory path.</param>
	/// <param name="TargetDirectory">The path to the target directory where backups will be stored. Must be a valid directory path.</param>
	/// <param name="Type">The type of backup to perform for this job.</param>
	public class BackupJob(int Id, string Name, string SourceDirectory, string TargetDirectory, BackupType Type)
	{
		public int Id { get; set; } = Id;

		public string Name { get; set; } = Name;

		public string SourceDirectory { get; set; } = SourceDirectory;

		public string TargetDirectory { get; set; } = TargetDirectory;

		[JsonConverter(typeof(JsonStringEnumConverter))]
		public BackupType Type { get; set; } = Type;

		[JsonIgnore]
		public IBackupStrategy Strategy { get; } = BackupStrategyFactory.CreateStrategy(Type);

		public DateTime LastExecution { get; set; }

		[JsonConverter(typeof(JsonStringEnumConverter))]
		public State State { get; set; } = State.Inactive;

		/// <summary>
		/// Executes the associated strategy and reports progress through the specified callback.
		/// </summary>
		/// <remarks>The method sets the state to active before execution and to completed after execution. The
		/// progress callback is invoked to provide updates during the execution process.</remarks>
		/// <param name="progressCallback">A callback method that receives progress updates as a <see cref="ProgressState"/> object. Cannot be null.</param>
		public void Execute(Action<ProgressState> progressCallback)
		{
			string BusinessSoftware = BackupManager.GetBM().ConfigManager.GetConfig("BusinessSoftware");
			State = State.Active;
            Strategy.Execute(this, BusinessSoftware, progressCallback);

            if (State != State.Error)
            {
                LastExecution = DateTime.Now;
                State = State.Completed;
            }
        }

		/// <summary>
		/// Transitions the current state to indicate an error has occurred.	
		/// </summary>
		/// <remarks>Call this method to set the object's state to an error condition. This may affect subsequent
		/// operations that depend on the current state.</remarks>
		public void Error()
		{
			State = State.Error;
		}

		public override bool Equals(object? obj)
		{
			if (obj == null)
				return false;
			if (obj == this)
				return true;
			if (obj is BackupJob job)
			{
				return job.Id == Id &&
					job.Name == Name &&
					job.SourceDirectory == SourceDirectory &&
					job.TargetDirectory == TargetDirectory &&
					job.Type == Type &&
					job.Strategy.GetType() == Strategy.GetType() &&
					job.State == State;
			}
			return false;
		}

		public override string ToString()
		{
			return $"Backup ID: {Id}, name: {Name}, Source: {SourceDirectory}, Destination: {TargetDirectory}, Type: {Type}, Strategy: {Strategy == null}, Last Execution: {LastExecution}, State: {State}";
		}

	}
}
</file>

<file path="EasySave/Backup/BackupManager.cs">
using EasyLog.Logging;
using EasySave.Utils;
using Newtonsoft.Json.Linq;

namespace EasySave.Backup
{
	/// <summary>
	/// Backup Manager - Singleton pattern for managing backup operations
	/// Acts as the ViewModel in MVVM architecture
	/// </summary>
	public class BackupManager
	{
		private static BackupManager? _instance;
		private static ILogger? _logger;
		private static readonly object _lock = new();
		
		private readonly List<BackupJob> _backupJobs;
		public readonly ConfigurationManager ConfigManager;
		private readonly StateWriter _stateWriter;

		public readonly int MaxBackupJobs;
		private readonly string appData;


		public Signal LatestSignal { get; private set; }
    
    /// <summary>
		/// Initializes a new instance of the BackupManager class and sets up required components and configuration.
		/// </summary>
		/// <remarks>This constructor is private and is intended to restrict instantiation of the BackupManager class
		/// to within the class itself, typically to implement a singleton or controlled creation pattern.</remarks>
		private BackupManager()
		{
			// Initialize paths
			appData = Path.Combine(
				Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
				"EasySave"
			);

			// Initialize components
			_stateWriter  = new StateWriter(Path.Combine(appData, "State"));
			ConfigManager = new ConfigurationManager(Path.Combine(appData, "Config"));

			MaxBackupJobs = ConfigManager.GetConfig("MaxBackupJobs");
			var useBackupJobLimit = ConfigManager.GetConfig("UseBackupJobLimit") as JValue;
			if (useBackupJobLimit?.Value is bool val && val == false)
				MaxBackupJobs = -1;

			// Load existing jobs
			_backupJobs = ConfigManager.LoadBackupJobs();

			LatestSignal = Signal.None;
		}

		/// <summary>
		/// Retrieves the singleton instance of the BackupManager.
		/// </summary>
		/// <remarks>This method ensures that only one instance of BackupManager exists throughout the application's
		/// lifetime. The instance is created on first access and is thread-safe.</remarks>
		/// <returns>The single instance of the BackupManager used by the application.</returns>
		public static BackupManager GetBM()
		{
			if (_instance == null)
			{
				lock (_lock)
				{
					_instance = new BackupManager();
				}
			}
			return _instance;
		}
		
		public static ILogger GetLogger()
		{
			if (_logger == null)
			{
				var BM = GetBM();
				var format = BM.ConfigManager.GetConfig("LoggerFormat");
				lock (_lock)
				{
					_logger = LoggerFactory.CreateLogger(format?.Value as string ?? "text", Path.Combine(BM.appData, "Logs"));
				}
			}
			return _logger;
		}
		
		/// <summary>
		/// Retrieves a list of all configured backup jobs.
		/// </summary>
		/// <returns>A list of <see cref="BackupJob"/> objects representing all backup jobs. The list will be empty if no jobs are
		/// configured.</returns>
		public List<BackupJob> GetAllJobs() => [.. _backupJobs];

		/// <summary>
		/// Attempts to add a new backup job with the specified parameters.
		/// </summary>
		/// <remarks>The method will not add a job if the maximum allowed number of backup jobs has already been
		/// reached. Parameter values must be valid and non-empty to successfully add a job.</remarks>
		/// <param name="name">The name of the backup job. Cannot be null, empty, or consist only of white-space characters.</param>
		/// <param name="sourceDir">The source directory to back up. Cannot be null, empty, or consist only of white-space characters.</param>
		/// <param name="targetDir">The target directory where the backup will be stored. Cannot be null, empty, or consist only of white-space
		/// characters.</param>
		/// <param name="type">The type of backup to perform for the job.</param>
		/// <returns>true if the backup job was added successfully; otherwise, false. Returns false if the maximum number of backup
		/// jobs has been reached or if any parameter is invalid.</returns>
		public bool AddJob(string? name, string? sourceDir, string? targetDir, BackupType type)
		{
			if (_backupJobs.Count >= MaxBackupJobs && MaxBackupJobs != -1)
				return false;

			if (string.IsNullOrWhiteSpace(name) ||
				string.IsNullOrWhiteSpace(sourceDir) ||
				string.IsNullOrWhiteSpace(targetDir))
			{
				return false;
			}

			if (string.IsNullOrEmpty(name) ||
				string.IsNullOrEmpty(sourceDir) ||
				string.IsNullOrEmpty(targetDir))
			{
				return false;
			}

			int newId = _backupJobs.Count != 0 ? _backupJobs.Max(j => j.Id) + 1 : 1;

			var job = new BackupJob(newId, name, sourceDir, targetDir, type);
			_backupJobs.Add(job);
			ConfigManager.SaveBackupJobs(_backupJobs);

			return true;
		}

		/// <summary>
		/// Deletes the backup job with the specified identifier.
		/// </summary>
		/// <param name="id">The unique identifier of the backup job to delete.</param>
		/// <returns>true if the backup job was found and deleted; otherwise, false.</returns>
		public bool DeleteJob(int id)
		{
			var job = _backupJobs.FirstOrDefault(j => j.Id == id);
			if (job == null)
				return false;

			_backupJobs.Remove(job);
			ConfigManager.SaveBackupJobs(_backupJobs);
			return true;
		}

		/// <summary>
		/// Executes the backup job with the specified identifier.
		/// </summary>
		/// <param name="id">The unique identifier of the backup job to execute.</param>
		/// <param name="progressCallback">An optional callback that receives progress updates during job execution. If null, progress updates are not
		/// reported.</param>
		/// <exception cref="ArgumentException">Thrown if a backup job with the specified ID does not exist.</exception>
		public bool ExecuteJob(int id, Action<ProgressState>? progressCallback = null)
		{
			var job = _backupJobs.FirstOrDefault(j => j.Id == id);
			if (job == null)
				throw new ArgumentException($"Backup job with ID {id} not found.");

			ExecuteSingleJob(job, progressCallback);

            return job.State != State.Error;
        }

		/// <summary>
		/// Executes all backup jobs with IDs in the specified inclusive range, optionally reporting progress for each job.
		/// </summary>
		/// <param name="startId">The first job ID in the range to execute. Must be less than or equal to <paramref name="endId"/>.</param>
		/// <param name="endId">The last job ID in the range to execute. Must be greater than or equal to <paramref name="startId"/>.</param>
		/// <param name="progressCallback">An optional callback that receives progress updates for each job as it is executed. If <see langword="null"/>, no
		/// progress is reported.</param>
		public void ExecuteJobRange(int startId, int endId, Action<ProgressState>? progressCallback = null)
		{
			for (int i = startId; i <= endId; i++)
			{
				var job = _backupJobs.FirstOrDefault(j => j.Id == i);
				if (job != null)
					ExecuteSingleJob(job, progressCallback);
			}
		}

		/// <summary>
		/// Executes the backup jobs corresponding to the specified job IDs, optionally reporting progress for each job.
		/// </summary>
		/// <param name="ids">An array of job identifiers specifying which backup jobs to execute. Only jobs with matching IDs will be
		/// processed.</param>
		/// <param name="progressCallback">An optional callback that receives progress updates for each job as it executes. If null, progress is not
		/// reported.</param>
		public void ExecuteJobList(int[] ids, Action<ProgressState>? progressCallback = null)
		{
			foreach (var id in ids)
			{
				var job = _backupJobs.FirstOrDefault(j => j.Id == id);
				if (job != null)
					ExecuteSingleJob(job, progressCallback);
			}
		}

		/// <summary>
		/// Executes all configured backup jobs in sequence, optionally reporting progress for each job.
		/// </summary>
		/// <remarks>Each backup job is executed in the order in which it was added. The method blocks until all jobs
		/// have completed. If a progress callback is provided, it is invoked for each job's progress updates.</remarks>
		/// <param name="progressCallback">An optional callback that receives progress updates for each job as a <see cref="ProgressState"/> instance. If
		/// <see langword="null"/>, no progress is reported.</param>
		public void ExecuteAllJobs(Action<ProgressState>? progressCallback = null)
		{
			foreach (var job in _backupJobs)
			{
				ExecuteSingleJob(job, progressCallback);
			}
		}

		/// <summary>
		/// Executes the specified backup job and updates progress using the provided callback.
		/// </summary>
		/// <remarks>If an exception occurs during job execution, the job is marked as failed and the error is logged
		/// before the exception is rethrown. The job's progress state is removed after execution completes, regardless of
		/// success or failure.</remarks>
		/// <param name="job">The backup job to execute. Cannot be null.</param>
		/// <param name="progressCallback">An optional callback that receives progress updates as the job executes. If null, progress updates are not
		/// reported to the caller.</param>
		private void ExecuteSingleJob(BackupJob job, Action<ProgressState>? progressCallback)
		{
			try
			{
				void ProgressHandler(ProgressState state)
				{
					_stateWriter.UpdateState(state);
					progressCallback?.Invoke(state);
				}

				job.Execute(ProgressHandler);

				ConfigManager.SaveBackupJobs(_backupJobs);
			}
			catch (Exception e)
			{
				job.Error();
				BackupManager.GetLogger().LogError(e);
				throw;
			}
			finally
			{
				_stateWriter.RemoveState(job.Name);
			}
		}

		public void TransmitSignal(Signal signal)
		{
			LatestSignal = signal;
		}

	}
}
</file>

<file path="README.md">
# 🛡️ EasySave - Version 2.0

**Solution de gestion de sauvegardes professionnelle avec interface graphique** Cette version marque le passage à une interface utilisateur moderne utilisant le framework **Avalonia** et intègre le logiciel de cryptage **CryptoSoft**.

---

## ✨ Nouveautés de la Version 2.0

* **Interface Graphique :** Une toute nouvelle expérience utilisateur développée sous le framework **Avalonia**.
* **Cryptage CryptoSoft :** Intégration de l'outil de chiffrement pour sécuriser les données sensibles selon les extensions configurées.
* **Travaux illimités :** Suppression de la limite des 5 travaux de sauvegarde.
* **Détection de Processus :** Le système surveille les **processus** métiers définis et suspend automatiquement les sauvegardes si l'un d'eux est détecté.

---

## 📋 Fonctionnalités Principales

* **Types de Sauvegarde :** Complète et Différentielle.
* **Multi-langue :** Support dynamique du Français et de l'Anglais.
* **Monitoring & Logs :** * Génération de logs journaliers aux formats JSON ou XML incluant les temps de cryptage.
    * **Note :** L'affichage de la progression n'est pas disponible dans cette version.

---

## 🚀 Installation et Compilation

### Prérequis Techniques
* .NET 8.0 SDK.
* Logiciel de cryptage **CryptoSoft.exe** présent dans le répertoire configuré.

### Depuis les sources
Pour compiler le projet en mode **Release** (optimisé pour l'exécution finale) :

1. Accéder au dossier du projet complet :  
   `cd EasySave.Desktop` (ou le nom exact de votre dossier projet)
2. Lancer la compilation :  
   `dotnet build EasySave.sln -c Release`

---

## 💻 Mode Console (Compatibilité)
L'application conserve une compatibilité ascendante pour les utilisateurs souhaitant piloter les sauvegardes via un terminal.

---

## 🏗️ Architecture Technique
Le logiciel est structuré autour du pattern **MVVM** pour garantir une séparation claire entre l'interface Avalonia et la logique métier de sauvegarde. L'ensemble est conçu pour être évolutif et faciliter la maintenance à long terme.

---

## 👥 Auteurs
**Groupe 1 - CESI Rouen** *Projet de Programmation Système - 3ème année Ingénieur Informatique.*
</file>

<file path="EasySave/Utils/ConfigurationManager.cs">
using EasySave.Backup;
using Newtonsoft.Json;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace EasySave.Utils
{
	/// <summary>
	/// Manages application configuration and backup jobs persistence
	/// </summary>
	public class ConfigurationManager
	{
		private static readonly JsonSerializerOptions JSON_OPTIONS = new()
		{
			WriteIndented = true,
			Converters = { new JsonStringEnumConverter() },
			IncludeFields = true
		};

		public readonly string _configDirectory;
		public readonly string _configFilePath;
		public readonly string _savedBackupJobPath;

		/// <summary>
		/// Gets the dynamic configuration values for the current instance.
		/// </summary>
		/// <remarks>The returned object provides access to configuration settings whose structure may vary at
		/// runtime. Use dynamic member access to retrieve specific configuration values as needed.</remarks>
		private dynamic ConfigValues { get; set; }

		/// <summary>
		/// Initializes a new instance of the ConfigurationManager class using the specified configuration directory. Ensures
		/// that the configuration files are created and loaded from the given directory.
		/// </summary>
		/// <remarks>If the configuration file does not exist or is empty, a default configuration is loaded. This
		/// constructor ensures that the configuration environment is set up and ready for use.</remarks>
		/// <param name="configDirectory">The path to the directory where configuration files are stored. If the directory does not exist, it will be
		/// created. Cannot be null or empty.</param>
		public ConfigurationManager(string configDirectory)
		{
			_configDirectory = configDirectory;

			if (!Directory.Exists(_configDirectory))
			{
				Directory.CreateDirectory(_configDirectory);
			}

			_configFilePath = Path.Combine(_configDirectory, "config.json");
			_savedBackupJobPath = Path.Combine(_configDirectory, "backups.json");
			if (!File.Exists(_configFilePath) || new FileInfo(_configFilePath).Length == 0)
			{
				File.WriteAllText(_configFilePath, ResourceManager.ReadResourceFile("default.json"));
			}
			string jsonContent = File.ReadAllText(_configFilePath);
			ConfigValues = JsonConvert.DeserializeObject(jsonContent);

		// Migrate configuration if needed
		MigrateConfigurationIfNeeded();
	}

	/// <summary>
	/// Migrates the configuration file to the latest version by merging existing values
	/// with new default values for any missing keys.
	/// </summary>
	private void MigrateConfigurationIfNeeded()
	{
		var defaultConfig = Newtonsoft.Json.JsonConvert.DeserializeObject<Newtonsoft.Json.Linq.JObject>(
			ResourceManager.ReadResourceFile("default.json"));
		
		if (defaultConfig == null) return;

		var currentConfig = ConfigValues as Newtonsoft.Json.Linq.JObject;
		if (currentConfig == null) return;

		bool configUpdated = false;

		// Add any missing keys from default config
		foreach (var property in defaultConfig.Properties())
		{
			if (currentConfig[property.Name] == null)
			{
				currentConfig[property.Name] = property.Value;
				configUpdated = true;
			}
		}

		// Update version if configuration was migrated
		if (configUpdated)
		{
			var defaultVersion = defaultConfig["Version"];
			if (defaultVersion != null)
			{
				currentConfig["Version"] = defaultVersion;
			}

			// Save the updated configuration
			File.WriteAllText(_configFilePath, currentConfig.ToString(Newtonsoft.Json.Formatting.Indented));
			ConfigValues = currentConfig;
		}
	}

		public dynamic GetConfig(string key)
		{
			return ConfigValues[key] ?? throw new ArgumentException("This configuration key doesn't exists!");
		}

		/// <summary>
		/// Loads all saved backup jobs from persistent storage.
		/// </summary>
		/// <remarks>If the backup jobs file does not exist or cannot be read, the method returns an empty list. The
		/// method does not throw exceptions for missing or invalid files.</remarks>
		/// <returns>A list of <see cref="BackupJob"/> objects representing the saved backup jobs. Returns an empty list if no backup
		/// jobs are found or if an error occurs while loading.</returns>
		public List<BackupJob> LoadBackupJobs()
		{
			if (!File.Exists(_savedBackupJobPath))
			{
				return [];
			}

			try
			{
				string jsonContent = File.ReadAllText(_savedBackupJobPath);
				var jobs = System.Text.Json.JsonSerializer.Deserialize<List<BackupJob>>(jsonContent);
				return jobs ?? [];
			}
			catch (Exception ex)
			{
				// Log l'erreur pour debug
				System.Diagnostics.Debug.WriteLine($"Error loading backup jobs: {ex.Message}");
				System.Diagnostics.Debug.WriteLine($"Exception details: {ex}");

				// Supprimer le fichier corrompu
				try
				{
					File.Delete(_savedBackupJobPath);
					System.Diagnostics.Debug.WriteLine($"Corrupted file deleted: {_savedBackupJobPath}");
				}
				catch { }
				BackupManager.GetLogger().LogError(ex);
				return [];
			}
		}
		
		/// <summary>
		/// Saves the specified collection of backup jobs to persistent storage.
		/// </summary>
		/// <param name="jobs">The list of <see cref="BackupJob"/> instances to be saved. Cannot be null.</param>
		/// <exception cref="Exception">Thrown if an error occurs while saving the backup jobs to storage.</exception>
		public void SaveBackupJobs(List<BackupJob> jobs)
		{
			try
			{
				//JSON_OPTIONS
				string jsonContent = System.Text.Json.JsonSerializer.Serialize(jobs, JSON_OPTIONS);
				File.WriteAllText(_savedBackupJobPath, jsonContent);
			}
			catch (Exception ex)
			{
				throw new Exception($"Failed to save configuration: {ex.Message}");
			}
		}
	}
}
</file>

</files>
